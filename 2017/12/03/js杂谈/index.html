<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="####随便记点 ===================================================================================== #####PS:prototype、proto、原型和原型链  在JS中，万物皆对象，对象因为你的“关注”而产生。每个对象都有自己">
<meta property="og:type" content="article">
<meta property="og:title" content="js杂谈">
<meta property="og:url" content="http://yoursite.com/2017/12/03/js杂谈/index.html">
<meta property="og:site_name" content="好带马的个人博客">
<meta property="og:description" content="####随便记点 ===================================================================================== #####PS:prototype、proto、原型和原型链  在JS中，万物皆对象，对象因为你的“关注”而产生。每个对象都有自己的属性特征和行为方法，函数、数组、对象等都可以被视为对象，那么js中的对象又是怎">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502247834723.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1501915356396.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1501915145731.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502162693702.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502162739963.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502162766604.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502162788094.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502162804098.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502162833510.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502162865617.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502162893891.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502163550506.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502163575063.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502163597440.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502163624964.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502163648019.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502163666738.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502163682791.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/clipboard.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502165642601.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502165669503.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502165692819.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502165707301.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502165783773.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502165807040.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502166964946.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172057370.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172127554.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172156876.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172189283.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172243456.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172284025.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172313643.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172335245.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172365940.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172407251.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172424500.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172441322.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172491156.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172555574.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172624759.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172696626.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172707979.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172724060.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172744794.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172762173.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172786415.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172864203.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172887901.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502172957318.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502173012717.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502173055839.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502173150296.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502173186549.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502173232556.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502173278002.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502173301042.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502173448680.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502173745894.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502173787555.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502173822819.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502173861020.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502173882070.png">
<meta property="og:image" content="http://yoursite.com/2017/12/03/js杂谈/1502173938698.png">
<meta property="og:updated_time" content="2017-12-03T09:33:42.384Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="js杂谈">
<meta name="twitter:description" content="####随便记点 ===================================================================================== #####PS:prototype、proto、原型和原型链  在JS中，万物皆对象，对象因为你的“关注”而产生。每个对象都有自己的属性特征和行为方法，函数、数组、对象等都可以被视为对象，那么js中的对象又是怎">
<meta name="twitter:image" content="http://yoursite.com/2017/12/03/js杂谈/1502247834723.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/03/js杂谈/"/>





  <title>js杂谈 | 好带马的个人博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7f7fc0818bf01cde8c4db632bad33df3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">好带马的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/js杂谈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daima Hao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="好带马的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">js杂谈</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T17:06:30+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>####<strong>随便记点</strong></p>
<p>=====================================================================================</p>
<p>#####<strong>PS:prototype、<strong>proto</strong>、原型和原型链</strong></p>
<blockquote>
<p>在JS中，万物皆对象，对象因为你的“关注”而产生。每个对象都有自己的属性特征和行为方法，函数、数组、对象等都可以被视为对象，那么js中的对象又是怎么产生的呢？</p>
<p>其他大型语言里，对象都和“类”这个概念紧密相连，“类”是对象的一个抽象概念，每个对象都是通过个“类”的构造方法创建的。而js中抛弃了“类”的概念，引入另外一个抽象概念——“原型”。js中每个对象都有一个原型，原型也是对象，所以原型也有自己的原型对象，如果一路找上去，最终会找到Object。也就是说js中所有对象都是由Object克隆出来的，Object是所有对象的起始。</p>
<p>创建对象的方法</p>
<p>1.构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let Construct=function(name,age)&amp;#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.age=age;</span><br><span class="line">&amp;#125;;</span><br><span class="line">let c1=new Construct(&quot;123&quot;,123);</span><br></pre></td></tr></table></figure></p>
<p>通过函数Construct，来创建一个实例对象c1，函数Construct也可称为构造函数。构造函数就是普通函数，只不过通过这个函数new了一个实例对象。在new的过程中通过构造函数的函数体，给对象c1增加了属性。</p>
</blockquote>
<p>2.构造函数加原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Construct=<span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)&amp;#123;</span></span><br><span class="line"><span class="function">    <span class="title">this</span>.<span class="title">name</span>=<span class="title">name</span>;</span></span><br><span class="line"><span class="function">    <span class="title">this</span>.<span class="title">age</span>=<span class="title">age</span>;</span></span><br><span class="line"><span class="function">&amp;#125;;</span></span><br><span class="line"><span class="function"><span class="title">Construct</span>.<span class="title">prototype</span>.<span class="title">fn</span>=<span class="title">function</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">log</span>(<span class="params"><span class="string">"hello world"</span></span>);</span></span><br><span class="line"><span class="function">&amp;#125;;</span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">c1</span>=<span class="title">new</span> <span class="title">Construct</span>(<span class="params"><span class="string">"123"</span>,<span class="number">123</span></span>);</span></span><br><span class="line"><span class="function"><span class="title">c1</span>.<span class="title">fn</span>(<span class="params"></span>);</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在构造函数的基础上，给构造函数的原型（Constructor.prototype）加一个方法fn，将该方法从构造函数的原型（Constructor.prototype）复制到新实例对象c1的原型（c1.prototype ）上。很多人会认为这两个是一个东西，我不这么认为，我理解为每一个对象都有一个自己的原型，下文会详细解释。这样构造函数原型中的方法就会被复制到c1的原型上，c1在自身中找不到fn这个方法，就会去自己的原型:c1. prototype 上去找。</p>
</blockquote>
<p>3.JSON<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let c1=&amp;#123;</span><br><span class="line">    <span class="string">"name"</span>:<span class="string">"123"</span>,</span><br><span class="line">    <span class="string">"age"</span>:<span class="number">123</span>,</span><br><span class="line">    <span class="string">"fn"</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">console</span>.<span class="title">log</span>(<span class="params"><span class="string">"hello world"</span></span>);</span></span><br><span class="line"><span class="function">    &amp;#125;,</span></span><br><span class="line"><span class="function">&amp;#125;;</span></span><br><span class="line"><span class="function"><span class="title">c1</span>.<span class="title">fn</span>(<span class="params"></span>);</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>JSON是js创建对象的一个简便算法，但也有它的缺点，在需要创建的对象数量很多时就不适用。构造函数创建的c1也有一个原型，这个原型为空，可以通过. prototype 给它的原型添加属性和方法。</p>
</blockquote>
<p>4.class</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Construct</span>&amp;#123</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&amp;#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.age=age;</span><br><span class="line">    &amp;#125;</span><br><span class="line">    fn()&amp;#123;</span><br><span class="line">        console.log("hello world");</span><br><span class="line">    &amp;#125;</span><br><span class="line">&amp;#125;</span><br><span class="line">let c1=new Construct();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先创建一个Construct的类，在通过new创建一个新的实例对象c1。在Construct这个类中，有一个名为constructor的函数，它可以把里面的属性通过new的过程初始化给c1；还有一个名为fn的方法，这个方法被直接添加到Construct的原型（Construct.prototype）上，在new的过程中又被复制到了c1的原型（c1. prototype ）上，所以c1本身没有这个方法，却可以通过原型链调用这个方法。</p>
<p>js的class是es6新增的一个概念，class的提出让我们在创建对象时的逻辑和操作更偏向于面向对象的语言。但它不是一个“真类”，是用函数模拟出来的一个“类”，底层和java等语言还是有很大的差别。</p>
<p>原型链</p>
<p>对象可以通过 . proto 这个方法找到该对象的原型，有一个特殊的对象——函数，函数通过.prototype找到该函数的原型对象，.prototype这个方法只有函数才可以调用，而找到的是原型对象，所以不能继续用.prototype这个方法。而. proto 这个方法可以重复调用，通过. proto . proto 来找到最顶层的原型对象Object，这条线就称为原型链。</p>
<p>不管是函数的原型还是实例对象的原型. proto 后都找到Object，也就是&#123;&#125;</p>
<p>原型对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Construct=<span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)&amp;#123;</span></span><br><span class="line"><span class="function">    <span class="title">this</span>.<span class="title">name</span>=<span class="title">name</span>;</span></span><br><span class="line"><span class="function">    <span class="title">this</span>.<span class="title">age</span>=<span class="title">age</span>;</span></span><br><span class="line"><span class="function">&amp;#125;;</span></span><br><span class="line"><span class="function"><span class="title">Construct</span>.<span class="title">prototype</span>.<span class="title">fn</span>=<span class="title">function</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">log</span>(<span class="params"><span class="string">"hello world"</span></span>);</span></span><br><span class="line"><span class="function">&amp;#125;;</span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">c1</span>=<span class="title">new</span> <span class="title">Construct</span>(<span class="params"><span class="string">"123"</span>,<span class="number">123</span></span>);</span></span><br></pre></td></tr></table></figure></p>
<p>Construct这个构造函数（也可视为对象）在我们声明的时候，就已经产生了一个原型对象<br>（Construct.prototype），通过原型对象添加的方法给上面加入方法fn，然后我们通过Construct，new一个新对象c1，要理解原型对象，首先我们要理解new的这个过程，new的过程一共分为3步：</p>
<p>先通过构造函数Construct来新建一个实例c1，并新建一个c1的原型对象：c1.prototype （此时，c1和c1. prototype 都是空的）。<br>c1. prototype = Construct.prototype（把Construct.prototype上的方法fn赋到c1.prototype 上，此时c1还是空的，c1. prototype 上有了一个方法fn）<br>通过函数Construct的函数体，对c1进行初始化设置，将属性和属性值赋给c1。<br>到此三步结束，c1中具有了属性和属性值，c1的原型（c1. prototype ）上有了fn这个方法，函数Construct的原型（Construct.prototype）没有改变，并且每次new对象的时候，都会重复上述的三个动作。可以通过分别查看c1、 c1. prototype 、Construct.prototype来验证刚才的证明。</p>
<p>并且我们在使用原型添加方法的时候，如果通过c1. prototype 来添加的属性和方法，并不会影响Construct.prototype里的内容，也不会影响其他新new出来的实例对象，只会改变c1自己的原型。而通过Construct.prototype去修改的原型，会影响其他新new出来的实例对象，这更好地解释了刚才的想法。</p>
</blockquote>
<p><img src="./1502247834723.png" alt="Alt text"></p>
<p>=====================================================================================</p>
<p>#####PS：sort排序原理：</p>
<blockquote>
<p>sort() 方法用于对数组的元素进行排序。<br>语法：arrayObject.sort(sortby)；参数sortby可选。规定排序顺序。必须是函数。<br>注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p>
<p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：<br>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。<br>若 a 等于 b，则返回 0。<br>若 a 大于 b，则返回一个大于 0 的值。</p>
</blockquote>
<p>例1：我们将创建一个数组，并按字母顺序进行排序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"James"</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"Adrew"</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"Martin"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr.sort())</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：</p>
<p>George,John,Thomas,James,Adrew,Martin<br>Adrew,George,James,John,Martin,Thomas</p>
</blockquote>
<p>例2：我们将创建一个数组，并按字母顺序进行排序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"10"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"5"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"40"</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"25"</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"1000"</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr.sort())</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：</p>
<p>10,5,40,25,1000,1<br>1,10,1000,25,40,5<br>请注意，上面的代码没有按照数值的大小对数字进行排序，要实现这一点，就必须使用一个排序函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumber</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function">&amp;#123;</span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="title">a</span> - <span class="title">b</span></span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">arr</span> = <span class="title">new</span> <span class="title">Array</span>(<span class="params"><span class="number">6</span></span>)</span></span><br><span class="line">arr[0] = "10"</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"5"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"40"</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"25"</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"1000"</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr.sort(sortNumber))</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<p>10,5,40,25,1000,1<br>1,5,10,25,40,1000<br>当然如果想根据数组对象中的某个属性值进行排序呢？</p>
<p>sort方法接收一个函数作为参数，这里嵌套一层函数用来接收对象属性名，其他部分代码与正常使用sort方法相同。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">    &amp;#123;name:'zopp',age:0&amp;#125;,</span><br><span class="line">    &amp;#123;name:'gpp',age:18&amp;#125;,</span><br><span class="line">    &amp;#123;name:'yjj',age:8&amp;#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">property</span>)&amp;#123;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">function</span>(<span class="params">a,b</span>)&amp;#123;</span></span><br><span class="line">        var value1 = a[property];</span><br><span class="line">        <span class="keyword">var</span> value2 = b[property];</span><br><span class="line">        <span class="keyword">return</span> value1 - value2;</span><br><span class="line">    &amp;#125;</span><br><span class="line">&amp;#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(compare(<span class="string">'age'</span>)))</span><br></pre></td></tr></table></figure></p>
<p>结果如图所示：</p>
<p>如何根据参数不同，来确定是升序排列，还是降序排序呢？<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sortBy: <span class="function"><span class="keyword">function</span>(<span class="params">attr,rev</span>)&amp;#123;</span></span><br><span class="line"><span class="function">    //第二个参数没有传递 默认升序排列</span></span><br><span class="line"><span class="function">    <span class="title">if</span>(<span class="params">rev ==  undefined</span>)&amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">rev</span> = 1;</span></span><br><span class="line"><span class="function">    &amp;#125;<span class="title">else</span>&amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">rev</span> = (<span class="params">rev</span>) ? 1 : -1;</span></span><br><span class="line"><span class="function">    &amp;#125;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">function</span>(<span class="params">a,b</span>)&amp;#123;</span></span><br><span class="line">        a = a[attr];</span><br><span class="line">        b = b[attr];</span><br><span class="line">        if(a &lt; b)&amp;#123;</span><br><span class="line">            <span class="keyword">return</span> rev * <span class="number">-1</span>;</span><br><span class="line">        &amp;#125;</span><br><span class="line">        if(a &gt; b)&amp;#123;</span><br><span class="line">            <span class="keyword">return</span> rev * <span class="number">1</span>;</span><br><span class="line">        &amp;#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &amp;#125;</span><br><span class="line">&amp;#125;</span><br></pre></td></tr></table></figure></p>
<p>使用方式：</p>
<p>newArray.sort(sortBy(‘number’,false)) </p>
</blockquote>
<font color="purple" size="3"><strong>ps:sort当对含有多个对象的数组进行排序不输入函数时</strong></font><br>&gt; 默认对每个对象的属性值按照首字母的ASCII码顺序排列，如果首字母相同就比较第二个字符，而不会对对象排序。<br><br>=====================================================================================<br><br>#####PS：with语句性能的因素：<br>&gt;- 再借地方放俩链：以V8为例，V8在Crankshaft编译架构下有两个JIT编译器，一个简单、不怎么优化的（叫做full-codegen），另外一个是优化编译器。优化编译器在把JavaScript AST parse成IR时如果看到with语句就直接放弃优化编译这个函数：bailout-reason.hhydrogen.cc 就跟vc大神说的一样。<br>&gt;<br>&gt; - Contra: The with statement forces the<br>specified object to be searched first for all name lookups. Therefore<br>all identifiers that aren’t members of the specified object will be<br>found more slowly in a ‘with’ block. Where performance is important,<br>‘with’ should only be used to encompass code blocks that access members<br> of the specified object.简单说，就是由于使用了with，对于所有变量查找，都会先在with指定的对象域内查找，查找失败，才会按照原JS标准作用域路径查找，因此，导致大量查找可能失败，但查找是很耗费性能的。<br>&gt;<br><br><br><br>=====================================================================================<br>#####PS：深入解析作用域<br>&gt;简单地说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域分为全局和局部两种。<br>拥有全局作用域就是在代码任何地方都能够访问到，叫做全局变量，以下三种情况可以拥有<br>全局作用域<br><br>&gt;最外层函数和最外层函数外面定义的变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[html] view plain copy</span><br><span class="line"><span class="keyword">var</span> name=<span class="string">"brizer"</span>;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)&amp;#123;  </span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">realname</span>="<span class="title">lf</span>";  </span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">innerSay</span>(<span class="params"></span>)&amp;#123;  </span></span><br><span class="line"><span class="function">        <span class="title">alert</span>(<span class="params">realname</span>);  </span></span><br><span class="line"><span class="function">    &amp;#125;  </span></span><br><span class="line"><span class="function">    <span class="title">innerSay</span>(<span class="params"></span>);  </span></span><br><span class="line"><span class="function">&amp;#125;  </span></span><br><span class="line"><span class="function"><span class="title">document</span>.<span class="title">write</span>(<span class="params">name</span>); //<span class="title">brizer</span>  </span></span><br><span class="line"><span class="function"><span class="title">document</span>.<span class="title">write</span>(<span class="params">realname</span>); //脚本错误  </span></span><br><span class="line"><span class="function"><span class="title">doSomething</span>(<span class="params"></span>); //<span class="title">lf</span>  </span></span><br><span class="line"><span class="function"><span class="title">innerSay</span>(<span class="params"></span>) //脚本错误</span></span><br></pre></td></tr></table></figure><br><br>未定义直接赋值的变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[html] view plain copy</span><br><span class="line"><span class="comment">/*全局作用域2：*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)&amp;#123;  </span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">name</span>="<span class="title">brizer</span>";  </span></span><br><span class="line"><span class="function">    <span class="title">realname</span>="<span class="title">lf</span>";  </span></span><br><span class="line"><span class="function">    <span class="title">document</span>.<span class="title">write</span>(<span class="params">name</span>);  </span></span><br><span class="line"><span class="function">&amp;#125;  </span></span><br><span class="line"><span class="function"><span class="title">doSomething</span>(<span class="params"></span>); //<span class="title">brizer</span>  </span></span><br><span class="line"><span class="function"><span class="title">document</span>.<span class="title">write</span>(<span class="params">realname</span>); //<span class="title">lf</span></span></span><br></pre></td></tr></table></figure><br><br>&gt;所有window对象：<br>一般情况下，所有window对象的内置属性都拥有全局作用域，如window.location等。<br><br>&gt;局部作用域<br>&gt;局部作用域只在固定的代码片段内可访问到。<br>如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[html] view plain copy</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)&amp;#123;  </span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">name</span>="<span class="title">lf</span>";  </span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">innerSay</span>(<span class="params"></span>)&amp;#123;  </span></span><br><span class="line"><span class="function">        <span class="title">alert</span>(<span class="params">name</span>);  </span></span><br><span class="line"><span class="function">    &amp;#125;  </span></span><br><span class="line"><span class="function">    <span class="title">innerSay</span>(<span class="params"></span>);  </span></span><br><span class="line"><span class="function">&amp;#125;  </span></span><br><span class="line"><span class="function"><span class="title">alert</span>(<span class="params">name</span>); //脚本错误  </span></span><br><span class="line"><span class="function"><span class="title">innerSay</span>(<span class="params"></span>); //脚本错误</span></span><br></pre></td></tr></table></figure><br><br>&gt;函数作用域<br>这里把函数作用域单独提出来讲并不是因为它和局部还有全局是平级关系，而是由于其比较特殊。javascript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里。这是javascript权威指南中的一句话，相当经典。<br>举个例子说，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[html] view plain copy</span><br><span class="line"><span class="comment">//函数运行在它们被定义的作用域里,而不是它们被执行的作用域  </span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'lf'</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">echo</span>(<span class="params"></span>) &amp;#123;  </span></span><br><span class="line"><span class="function">          <span class="title">document</span>.<span class="title">write</span>(<span class="params">name</span>);  </span></span><br><span class="line"><span class="function">     &amp;#125;  </span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">     <span class="title">function</span> <span class="title">env</span>(<span class="params"></span>) &amp;#123;  </span></span><br><span class="line"><span class="function">          <span class="title">var</span> <span class="title">name</span> = '<span class="title">brizer</span>';  </span></span><br><span class="line"><span class="function">          <span class="title">echo</span>(<span class="params"></span>);  </span></span><br><span class="line"><span class="function">     &amp;#125;  </span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">     <span class="title">env</span>(<span class="params"></span>);</span></span><br></pre></td></tr></table></figure><br><br>&gt;最后结果的lf而不是brizer。说明函数在定义时，它的作用域就已经决定了。<br>作用域链<br>下面我们说说作用域链，在javascript中，函数也是对象，实际上，javascript中的一切都是对象。函数内部有一个只给javascript引擎访问的内部属性是[[scope]]，该属性包含了函数创建时的作用域中对象的集合，这个集合就叫做作用域链。<br><br>比如下面代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[html] view plain copy</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>) &amp;#123;  </span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">sum</span> = <span class="title">num1</span> + <span class="title">num2</span>;  </span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">sum</span>;  </span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br></pre></td></tr></table></figure><br><br>&gt;在函数创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量，如下图：<br><br>&gt;当函数被执行时，会创建一个活动对象，该对象包含了函数所有局部变量、命名参数以及this，然后该对象会被推入作用域链的前端，当函数执行完毕，该对象也随之销毁。如下图：<br><br>&gt;可以看到，全局变量会被活动对象推到作用域链的最后端，这也就是为什么全局变量访问速度慢的原因！<br><br>&gt;with<br>一般情况下，作用域链只会被with和catch语句影响。当使创建用with的时候，函数会创建一个新的活动对象，推到最前端，该对象就是with的对象。这就意味着所有的局部变量都处于第二个作用域链对象中去了，这也就是为什么要避免使用with的原因。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[html] view plain copy</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initUI</span>(<span class="params"></span>)&amp;#123;  </span></span><br><span class="line"><span class="function">    <span class="title">with</span>(<span class="params">document</span>)&amp;#123;  </span></span><br><span class="line"><span class="function">        <span class="title">var</span> <span class="title">bd</span>=<span class="title">body</span>,  </span></span><br><span class="line"><span class="function">            <span class="title">links</span>=<span class="title">getElementsByTagName</span>(<span class="params"><span class="string">"a"</span></span>),  </span></span><br><span class="line"><span class="function">            <span class="title">i</span>=0,  </span></span><br><span class="line"><span class="function">            <span class="title">len</span>=<span class="title">links</span>.<span class="title">length</span>;  </span></span><br><span class="line"><span class="function">        <span class="title">while</span>(<span class="params">i &lt; len</span>)&amp;#123;  </span></span><br><span class="line"><span class="function">            <span class="title">update</span>(<span class="params">links[i++]</span>);  </span></span><br><span class="line"><span class="function">        &amp;#125;  </span></span><br><span class="line"><span class="function">        <span class="title">getElementById</span>(<span class="params"><span class="string">"btnInit"</span></span>).<span class="title">onclick</span>=<span class="title">function</span>(<span class="params"></span>)&amp;#123;  </span></span><br><span class="line"><span class="function">            <span class="title">doSomething</span>(<span class="params"></span>);  </span></span><br><span class="line"><span class="function">        &amp;#125;;  </span></span><br><span class="line"><span class="function">    &amp;#125;  </span></span><br><span class="line"><span class="function">&amp;#125; </span></span><br><span class="line"><span class="function">``` </span></span><br><span class="line"><span class="function">=====================================================================================</span></span><br><span class="line"><span class="function">&gt;  #####**关于全局变量访问变慢的问题实验：**</span></span><br><span class="line"><span class="function">``` <span class="title">javascript</span></span></span><br><span class="line"><span class="function">	<span class="title">var</span> <span class="title">i</span> = 3;</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">obj</span> = &amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">num</span>: 1,</span></span><br><span class="line"><span class="function">        <span class="title">age</span>: 2</span></span><br><span class="line"><span class="function">    &amp;#125;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">Fn</span>(<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">var</span> <span class="title">a</span> = 9;</span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">a</span>;</span></span><br><span class="line"><span class="function">    &amp;#125;</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">time</span>(<span class="params"><span class="string">"test1"</span></span>);</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">log</span>(<span class="params">i</span>);</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">timeEnd</span>(<span class="params"><span class="string">"test1"</span></span>);</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">time</span>(<span class="params"><span class="string">'test2'</span></span>);</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">log</span>(<span class="params">obj.num</span>);</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">timeEnd</span>(<span class="params"><span class="string">"test2"</span></span>);</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">time</span>(<span class="params"><span class="string">'test3'</span></span>)</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">log</span>(<span class="params">Fn(</span>));</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">timeEnd</span>(<span class="params"><span class="string">'test3'</span></span>);</span></span><br></pre></td></tr></table></figure><br><br><img src="./1501915356396.png" alt="Alt text"><br><br><strong><font size="5">疑问</font></strong>：<br>&gt;当把全局变量注释掉不显示以后，obj局部变量的访问会大大减慢，不知道原因。。。<br><br><img src="./1501915145731.png" alt="Alt text"><br><br><br>=====================================================================================<br>#####<strong>call、apply和bind</strong><br><br>&gt; 回想起之前的一些面试，几乎每次都会问到一个js中关于call、apply、bind的问题，比如…<br><br>&gt; 怎么利用call、apply来求一个数组中最大或者最小值<br><br>&gt; 如何利用call、apply来做继承<br><br>&gt;apply、call、bind的区别和主要应用场景<br><br>&gt;虽然网上有很多关于这方面的博客和文章，但还是决定写一篇自己对这方面知识的理解。<br><br><br>01-作用<br>&gt;首先问个问题，这三个函数的存在意义是什么？答案是改变函数执行时的上下文，再具体一点就是改变函数运行时的this指向。有了这个认识，接下来我们来看一下，怎么使用这三个函数。<br><br>&gt;举个栗子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)&amp;#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">this</span>.<span class="title">name</span> = <span class="title">name</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Person</span>.<span class="title">prototype</span> = &amp;#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">constructor</span>: <span class="title">Person</span>,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">showName</span>: <span class="title">function</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span>(<span class="params">this.name</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">person</span> = <span class="title">new</span> <span class="title">Person</span>(<span class="params"><span class="string">'qianlong'</span></span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">person</span>.<span class="title">showName</span>(<span class="params"></span>);</span></span><br></pre></td></tr></table></figure><br><br>上面的代码中person调用showName方法后会在浏览器的控制台输出qianlong<br><br>接下来<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var animal = &amp;#123;</span><br><span class="line"></span><br><span class="line">name: <span class="string">'cat'</span></span><br><span class="line"></span><br><span class="line">&amp;#125;</span><br></pre></td></tr></table></figure><br><br>上面代码中有一个对象字面量，他没有所谓的showName方法，但是我还是想用？怎么办？(坑爹了，这好像在让巧媳妇去做无米之炊)，不过没关系，call、apply、bind可以帮我们干这件事。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 call</span></span><br><span class="line"></span><br><span class="line">person.showName.call(animal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 apply</span></span><br><span class="line"></span><br><span class="line">person.showName.apply(animal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 bind</span></span><br><span class="line"></span><br><span class="line">person.showName.bind(animal)();</span><br></pre></td></tr></table></figure><br><br>啦啦啦，有木有很神奇，控制台输出了三次cat<br><br>我们拿别人的showName方法，并动态改变其上下文帮自己输出了信息，说到底就是实现了复用<br><br><br>02-区别<br><br>&gt;上面看起来三个函数的作用差不多，干的事几乎是一样的，那为什么要存在3个家伙呢，留一个不就可以。所以其实他们干的事从本质上讲都是一样的动态的改变this上下文,但是多少还是有一些差别的..<br><br>&gt;call、apply与bind的差别<br><br>&gt;call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数。<br><br>&gt;call、apply的区别<br><br>&gt;他们俩之间的差别在于参数的区别，call和aplly的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。<br><br>&gt;fn.call(obj, arg1, arg2, arg3…);<br><br>&gt;fn.apply(obj, [arg1, arg2, arg3…]);<br><br>03-应用<br><br>&gt;知道了怎么使用和他们之间的区别，接下来我们来了解一下通过call、apply、bind的常见应用场景。<br><br>&gt;求数组中的最大和最小值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">-67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">-8</span>,<span class="number">687</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>, <span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">-67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">-8</span>,<span class="number">687</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, arr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.min.call(<span class="built_in">Math</span>, <span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">-67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">-8</span>,<span class="number">687</span>);</span><br></pre></td></tr></table></figure><br><br>&gt;将伪数组转化为数组<br><br>&gt;js中的伪数组(例如通过document.getElementsByTagName获取的元素)具有length属性，并且可以通过0、1、2…下标来访问其中的元素，但是没有Array中的push、pop等方法。我们可以利用call、apply来将其转化为真正的数组这样便可以方便地使用数组方法了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arrayLike = &amp;#123;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: <span class="string">'qianlong'</span>,</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>: <span class="string">'ziqi'</span>,</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>: <span class="string">'qianduan'</span>,</span><br><span class="line"></span><br><span class="line">length: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">&amp;#125;</span><br></pre></td></tr></table></figure><br><br>&gt;上面就是一个普通的对象字面量，怎么把它变成一个数组呢？最简单的方法就是<br><br>&gt;var arr = Array.prototype.slice.call(arrayLike);<br><br>&gt;上面arr便是一个包含arrayLike元素的真正的数组啦( 注意数据结构必须是以数字为下标而且一定要有length属性 )<br><br>&gt;数组追加<br><br>&gt;在js中要往数组中添加元素，可以直接用push方法，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">[].push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr1 [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2 [4,5,6]</span></span><br></pre></td></tr></table></figure><br><br>&gt;判断变量类型<br><br>&gt;对于对象型的数据类型，我们可以借助call来得知他的具体类型，例如数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>)&amp;#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">return Object.prototype.toString.call(obj) == '[object Array]';</span><br><span class="line"></span><br><span class="line">&amp;#125;</span><br><span class="line"></span><br><span class="line">isArray([]) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">isArray(<span class="string">'qianlong'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><br><br>=====================================================================================<br>#####<strong>DOM的映射</strong><br>        通过DOM方法获取的一个元素集合(类数组),这个集合仍然和页面的元素保持着联系,并且这个元素集合会随着页面元素的增加而增加,减少而减少,即使把这个数组转为一个新数组,每个元素仍然和页面有联系,这就叫做”DOM映射”<br>–<br><br>&gt;回流:<br>元素的<font color="red">位置发生改变</font>(增加元素,删除元素,移动)引起回流,让整个页面重新渲染一遍,从而造成性能浪费<br>–<br><br>重绘:<br>元素<font color="red">样式发生改变</font>,就会把当前这个元素重新渲染一遍所以在以后项目中,能用重绘代替的就不用回流,能用一次回流就不用使用多次<br>–<br><br>向页面增加元素的方式<br><br>1.动态创建的方式document<br>.document.createElement,然后一个一个appendChild,会造成多次回流,这样不好,但是他有个好处是不会改变原来的元素(比如不会影响他之前绑定的事件);<br><br>2.通过拼接字符串,最后在一次性通过innerHTML,这样只会引起一次回流,这样比较好,但是他会改变原来的元素(比如会影响之前绑定的事件);<br><br>3.关键点!”文档碎片”,他就是个容器专门来盛放DOM元素的<br>例子:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flg=<span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    for (var i=0;i&lt;jsonData.length;i++)&amp;#123;</span><br><span class="line">        <span class="keyword">var</span> oli=<span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">        oli.innerHTML=jsonData[i].content;</span><br><span class="line">        oli.className=jsonData[i].class;</span><br><span class="line">        flg.appendChild(oli);</span><br><span class="line">    &amp;#125;</span><br><span class="line">    news.appendChild(flg);</span><br><span class="line">    flg=<span class="literal">null</span>;<span class="comment">//用完了 没有用了，就清空</span></span><br><span class="line">&amp;#125;</span><br></pre></td></tr></table></figure><br><br>步骤:<br>1.先给创建元素 var oli=document.createElement(“li”)<br>2.按需求给元素增加一些需要的属性<br>3.暂时存放在flg(DOM碎片)中,也是appendChild进去的<br>4.循环完之后,把整flg放到ul中,news.appendChild(flg)<br>这样就只会引起一次回流<br><br>=====================================================================================<br><br>#####<strong>localcompare问题</strong><br>1.ES5中localcompare方法的实现原理：<br>&gt;String.prototype.localeCompare (that)<br><br> &gt;当以一个参数 that 来调用 localeCompare 方法，它返回一个非 NaN 数字值，这个数字值反应了对 this 值（转换为字符串）和 that 值（转换为字符串）进行语言环境敏感的字符串比较的结果。两个字符串 S 和 That 用实现定义的一种方式进行比较。比较结果是为了按照系统默认语言环境指定的排列顺序来排列字符串，根据按照排列顺序 S 是在 That 前面，相同，还是 S 在 That 后面，结果分别是负数，零，正数。<br><br> &gt;在执行比较之前执行以下步骤以预备好字符串：<br><br>&gt;以 this 值作为参数调用 CheckObjectCoercible。<br>&gt;令 S 为以 this 值作为参数调用 ToString 的结果 .<br>令 That 为 ToString(that).<br>&gt; 如果将 localeCompare 方法看做是将 this 和 that 作为两个参数的函数，那么它是在所有字符串集合上的保持一致的比较函数（在 15.4.4.11 定义）。<br><br> &gt;实际返回值是实现定义的，允许实现者们在返回值里编码附加信息。但是函数需要定义一个在所有字符串上的总的顺序，并且，当比较的字符串们被认为是 Unicode 标准定义的标准等价，则返回 0。<br><br>&gt; 如果宿主环境没有在所有字符串上语言敏感(<strong>可能指的是除了英语以外的象形文字</strong>)的比较，此函数可执行按位比较。<br><br>&gt;localeCompare 方法自身不适合直接作为 Array.prototype.sort 的参数，因为后者需要的是两个参数的函数。<br><br>&gt;这个函数的目的是在宿主环境中任何依靠语言敏感的比较方式都可用于 ECMAScript 环境，并根据宿主环境当前语言环境设置的规则进行比较。强烈建议这个函数将 – 根据 Unicode 标准的标准等价的 – 字符串当做是相同的（也就是说，要比较的字符串仿佛是都先被转换为正常化形式 C 或正常化形式 D 了）。还建议这个函数不履行 Unicode 相容等价或分解。<br><br>&gt;本标准的未来版本可能会使用这个函数的第二个参数；建议实现不将这个参数位用作其他用途。<br><br>&gt;localeCompare 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。<br><br>=====================================================================================<br>#####<strong>关于使用汉字拼音使用localecompare出现不按期望顺序排列的问题研究</strong><br><strong>可能的原因及经过测试可行的方法(暂时看不太懂包括（<font color="purple">可能包括C#）)</font></strong><br>&gt;1.一般来说，人们将使用以下方法进行汉字拼音排序<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list=[<span class="string">' king '</span>, <span class="string">'a'</span>, <span class="string">'li'</span>];  </span><br><span class="line">list.Sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) &amp;#123;<span class="title">return</span> <span class="title">a</span>.<span class="title">localeCompare</span>(<span class="params">b</span>); &amp;#125;);</span></span><br><span class="line"><span class="function"><span class="title">localeCompare</span>（）：具有本地特定的顺序来比较两个字符串。</span></span><br></pre></td></tr></table></figure><br><br>&gt;拼音排序的方法是不可靠的。<br><br>&gt;第二种方式：非常依赖中文操作系统<br><br>&gt;非常依赖浏览器内核，就是说，如果你的网站访问者是通过中文系统，或浏览器浏览器（Chrome），那么他可能无法看到拼音排序我们预期的结果。<br><br>&gt;<strong>重写的compare方法来实现的localcompare</strong>   在这里，我将介绍我的解决方案，希望能够得到某种方式：这个方法支持从0到0 x9fa5区域的Unicode字符集x4e00从中国（包括台湾），日本，韩国，汉字，即日本汉字（CJK）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var CompareStrings=&amp;#123;.........&amp;#125;</span><br><span class="line">getOrderedUnicode: <span class="function"><span class="keyword">function</span> (<span class="params">char</span>) &amp;#123;</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">originalUnicode</span>=<span class="title">char</span>.<span class="title">charCodeAt</span> (<span class="params"></span>); </span></span><br><span class="line"><span class="function"><span class="title">if</span> (<span class="params">originalUnicode &gt;=<span class="number">0</span> x4e00 &amp;&amp; originalUnicode &lt;=<span class="number">0</span> x9fa5</span>) &amp;#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//判断字符的<span class="title">unicode</span>码是否在中文的范围 4<span class="title">E00</span>-9<span class="title">FA5</span>内。</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">index</span>=<span class="title">this</span>.<span class="title">Db</span>.<span class="title">IndexOf</span> (<span class="params">char</span>); </span></span><br><span class="line"><span class="function"><span class="title">if</span> (<span class="params">index &gt;<span class="number">1</span></span>) &amp;#123;</span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="title">index</span> + 0 <span class="title">x4e00</span>; </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&amp;#125;&amp;#125; </span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="title">originalUnicode</span>; </span></span><br><span class="line"><span class="function">&amp;#125;, </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">compare</span>: <span class="title">function</span> (<span class="params">a, b</span>) &amp;#123;</span></span><br><span class="line"><span class="function"><span class="title">if</span> (<span class="params">a==b</span>) &amp;#123;<span class="title">return</span> 0; &amp;#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//<span class="title">here</span> <span class="title">can</span> <span class="title">be</span> <span class="title">rewritten</span> <span class="title">according</span> <span class="title">to</span> <span class="title">the</span> <span class="title">specific</span> <span class="title">needs</span> <span class="title">and</span> <span class="title">the</span> <span class="title">writing</span> <span class="title">is</span> <span class="title">the</span> <span class="title">empty</span> <span class="title">string</span> <span class="title">at</span> <span class="title">the</span> <span class="title">bottom</span> <span class="title">the</span> <span class="title">if</span> (<span class="params">a.length==<span class="number">0</span></span>) &amp;#123;<span class="title">return</span> 1; &amp;#125; </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">if</span> (<span class="params">b.length==<span class="number">0</span></span>) &amp;#123;<span class="title">return</span> - 1; &amp;#125; </span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">count</span>=<span class="title">a</span>.<span class="title">length</span> &gt;<span class="title">B</span>.<span class="title">length</span>? <span class="title">B</span>.<span class="title">length</span>: <span class="title">a</span>.<span class="title">length</span>; </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">for</span> (<span class="params">var i=<span class="number">0</span>; i&lt;count; i++</span>) &amp;#123;</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">au</span>=<span class="title">this</span>.<span class="title">GetOrderedUnicode</span> (<span class="params">a [i]</span>); </span></span><br><span class="line">var bu=this.GetOrderedUnicode [i] (b); </span><br><span class="line">if (au &gt;bu) &amp;#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&amp;#125; else if (au &lt;bu) &amp;#123;</span><br><span class="line"><span class="keyword">return</span> - <span class="number">1</span>; </span><br><span class="line">&amp;#125;&amp;#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a.length &gt;B.length? <span class="number">1</span>:<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&amp;#125;&amp;#125; </span><br><span class="line"><span class="comment">//rewriting system native localeCompare</span></span><br></pre></td></tr></table></figure><br><br>&gt;原型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocaleCompare = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) &amp;#123;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">CompareStrings</span>.<span class="title">compare</span> <span class="title">said</span> (<span class="params">enclosing the toString (</span>), <span class="title">param</span>); </span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br></pre></td></tr></table></figure><br><br>&gt;您可以通过以下链接下载完整的代码<br><br>&gt;简要介绍实施原则：<br><br>&gt;根据拼音排序好字符（db）：有多种方式来实现一个目标，我完成了JavaScript + c＃组合，使用脚本首先把所有的汉字列举，然后提交到c #good背景排序，并输出到前台，这只是准备，什么都可以。<br>&gt;识别两个较大的字符（getOrderedUnicode）：因为在派寻时，不仅要处理汉字和汉字外的字符，所以比较器必须能够识别所有的字符，我们这里通过判断一个字符是区分汉字：如果是汉字，那么排序好的字库搜索索引，索引值加上Unicode字符设置第一个汉字的位置，是在“校准”后的Unicode字符集指数值 如果不是汉字，则直接在Unicode字符集的索引值上返回。<br>&gt;比较两个字符串（比较）：通过比较两个字符（在有效范围比较中，即字符串的长度越短），如果发现大于b，则返回1，副返回1。<br>&gt;在比较之后的有效范围内，如果没有领带，只要看谁是更长的，比如a =’123’，b =’1234’，那么长b在后面排。<br>编辑<br><br>&gt;你也可以使用JQuery插件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend( jQuery.fn.dataTableExt.oSort, &amp;#123;</span><br><span class="line">    <span class="string">"chinese-string-asc"</span> : <span class="function"><span class="keyword">function</span> (<span class="params">s1, s2</span>) &amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">s1</span>.<span class="title">localeCompare</span>(<span class="params">s2</span>);</span></span><br><span class="line"><span class="function">    &amp;#125;,</span></span><br><span class="line"><span class="function">    "<span class="title">chinese</span>-<span class="title">string</span>-<span class="title">desc</span>" : <span class="title">function</span> (<span class="params">s1, s2</span>) &amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">s2</span>.<span class="title">localeCompare</span>(<span class="params">s1</span>);</span></span><br><span class="line"><span class="function">    &amp;#125;</span></span><br><span class="line"><span class="function">&amp;#125; );</span></span><br></pre></td></tr></table></figure><br><br>&gt;2. 中文拼音只有gb2312一级字库的汉字是按拼音组织的<br>所以你当按汉字内码排序时，并不都符合拼音顺序<br><br><br>&gt;存在的疑问：<br>1.在chorme下测试，经过测试’沈’和’陈’比较显示-1，意思是沈在陈前面，但是沈的首字母是s，陈的是c所以不是按照常规首字母排序，经过查找发现沈的Unicode码沈的是\u6c88，而陈的是\u9648，按照这个逻辑是-1，但是测试另外一组’赵’和’钱’的Unicode码分别是\u8d75和\u94b1，按照unicode码的顺序返回的该是-1，但事实是1，所以证明排序规则并不是完全按照Unicode码中的顺序，参照MDN关于localecompare的文档，localeCompare() 方法提供的比较字符串的方法，考虑了默认的本地排序规则。ECMAscript 标准并没有规定如何进行本地特定的比较操作，它只规定该函数采用<font color="red">底层操作系统提供的排序规则。所以对这个操作系统的底层排序规则暂时查不明白。<br><br><br>=====================================================================================<br><br>#####<strong>关于使用文档碎片向页面中添加内容和直接向页面添加内容所耗性能的实验</strong><br><br>1.已知后者肯定会导致一次dom回流或者多次dom重绘，对于文档碎片是否会导致dom回流尚不确定，暂且认为其也会导致一次dom回流。思路是利用：console.time，在数据向页面绑定代码段测试使用直接向页面添加和利用文档碎片添加的所耗时间。<br>统计100次：<br>- 使用文档碎片结果：大部分结果在0.08ms到0.47ms之间，期间有两次出现2.27ms和3.96ms（认为是特殊情况。）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'test'</span>);</span><br><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">sortRows</span>(<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function">    //-&gt;把存储所有行的类数组转换为数组(<span class="params">只有数组才能用SORT方法进行排序</span>)</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">stuRowsAry</span> = <span class="title">utils</span>.<span class="title">toArray</span>(<span class="params">stuRows</span>);</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">_this</span>=<span class="title">this</span>;</span></span><br><span class="line"><span class="function">    //-&gt;让所有的行按照年龄这一列由小到大排序</span></span><br><span class="line"><span class="function">    <span class="title">stuRowsAry</span>.<span class="title">sort</span>(<span class="params">function (a, b</span>) &amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">var</span> <span class="title">curAge</span> = <span class="title">parseFloat</span>(<span class="params">a.cells[<span class="number">2</span>].innerHTML</span>);</span></span><br><span class="line"><span class="function">        <span class="title">var</span> <span class="title">nextAge</span> = <span class="title">parseFloat</span>(<span class="params">b.cells[<span class="number">2</span>].innerHTML</span>);</span></span><br><span class="line"><span class="function">        <span class="title">return</span> (<span class="params">curAge - nextAge</span>)*<span class="title">_this</span>.<span class="title">n</span>;</span></span><br><span class="line"><span class="function">    &amp;#125;);</span></span><br><span class="line"><span class="function">    //-&gt;按照数组排好的顺序,我们把每一行重新的放入到页面中,让页面中的结构也跟着排序</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">frg</span> = <span class="title">document</span>.<span class="title">createDocumentFragment</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function">    <span class="title">for</span> (<span class="params">var i = <span class="number">0</span>; i &lt; stuRowsAry.length; i++</span>) &amp;#123;</span></span><br><span class="line">        var curRow = stuRowsAry[i];</span><br><span class="line">        frg.appendChild(curRow);</span><br><span class="line">    &amp;#125;</span><br><span class="line">    stuBody.appendChild(frg);</span><br><span class="line">    frg = <span class="literal">null</span>;</span><br><span class="line">&amp;#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure><br><br>- 直接向页面容器添加：<br>- 统计100次：<br>-  直接向页面添加元素结果：大部分结果在0.08到0.45之间，期间没有出现超过1ms的情况，仅发现一次0.58ms。<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">console</span>.time(<span class="string">'test'</span>);</span><br><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">sortRows</span>(<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function">    //-&gt;把存储所有行的类数组转换为数组(<span class="params">只有数组才能用SORT方法进行排序</span>)</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">stuRowsAry</span> = <span class="title">utils</span>.<span class="title">toArray</span>(<span class="params">stuRows</span>);</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">_this</span>=<span class="title">this</span>;</span></span><br><span class="line"><span class="function">    //-&gt;让所有的行按照年龄这一列由小到大排序</span></span><br><span class="line"><span class="function">    <span class="title">stuRowsAry</span>.<span class="title">sort</span>(<span class="params">function (a, b</span>) &amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">var</span> <span class="title">curAge</span> = <span class="title">parseFloat</span>(<span class="params">a.cells[<span class="number">2</span>].innerHTML</span>);</span></span><br><span class="line"><span class="function">        <span class="title">var</span> <span class="title">nextAge</span> = <span class="title">parseFloat</span>(<span class="params">b.cells[<span class="number">2</span>].innerHTML</span>);</span></span><br><span class="line"><span class="function">        <span class="title">return</span> (<span class="params">curAge - nextAge</span>)*<span class="title">_this</span>.<span class="title">n</span>;</span></span><br><span class="line"><span class="function">    &amp;#125;);</span></span><br><span class="line"><span class="function">    //-&gt;按照数组排好的顺序,我们把每一行重新的放入到页面中,让页面中的结构也跟着排序</span></span><br><span class="line"><span class="function">    // <span class="title">var</span> <span class="title">frg</span> = <span class="title">document</span>.<span class="title">createDocumentFragment</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function">    <span class="title">for</span> (<span class="params">var i = <span class="number">0</span>; i &lt; stuRowsAry.length; i++</span>) &amp;#123;</span></span><br><span class="line">        var curRow = stuRowsAry[i];</span><br><span class="line">        stuBody.appendChild(curRow);</span><br><span class="line">    &amp;#125;</span><br><span class="line">    <span class="comment">// stuBody.appendChild(frg);</span></span><br><span class="line">    <span class="comment">// frg = null;</span></span><br><span class="line">&amp;#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure><br><br>&gt; <font color="red"><strong>总结：</strong> </font><br>&gt; 经结果看来两者所耗时间几乎相同，只是似乎直接向页面容器添加元素的方法比文档碎片还要好那么一丢丢，关于文档碎片方法出现的以外高时长考虑可能为程序问题或者设备问题，此外，这次实验可能受到过多的外界原因和程序的编写不合理性影响，因为之前查看网络文档普遍认为文档碎片是一种较好的方式，至于为什么会出现这样的结果，暂时还想不出来，留到以后解决，暂时实验到这。哈哈。。。<br><br><br><br><br><br>&gt;知乎关于类似问题的讨论：<br><br><br>DocumentFragment真的能提高 JS 动态添加 DOM 的性能吗？<br>不知从何时起在网上看到过一篇博文提到利用DocumentFragment提高JS动态添加大量DOM的性能，主要论据是每次调用node.appendChild()都会引起 reflow，而通过先把 DOM 暂存在DocumentFragment，从而达到只需要一次 reflow的目的。<br>当时还是太年轻的我从此便奉为金科玉律。直到今天不知何故突然脑洞大开：在浏览器当中 JS 不是会阻塞 UI 的渲染吗，那为什么在一个循环里边动态添加多个 DOM 会引起多次 reflow 呢？这明显不科学嘛，此时 UI 应该是被 blocked 才对。。<br><br>于是我写了一些代码来测试我的想法。。<br><br><br>测试结果发现时间基本无差别。。难道是现在的浏览器高端到 JS 不会阻塞 UI 渲染了吗？于是我又写了些代码。。<br><br>测试结果是 JS 还是会阻塞 UI 的，于是我迷茫了。。求大神答疑解惑~~<br><br><br>&gt; 回答1：<br>&gt;题主你怎么从写的第二段代码得出“JS 不会阻塞 UI 渲染了”的看法的？有些事情只在节点被插入到真正的document时才发生，这是document fragment更快的基本原因。document fragment从机制上比较接近innerHTML，只是前者确保了dom结构。其他大量的事情其实要等到被插入document之后才发生。比如当你append到document时，被append进去的元素的样式表的计算是同步发生的，此时getComputedStyle可以得到样式的计算值。而append到document fragment，没样式表什么事，可以省下这个计算。再如，script节点只有append到document时，才会真的parse和执行。注意阻塞UI不是阻塞reflow。如果你在append到document之后去访问下clientHeight这样的属性，其实会block住直到reflow完成。但是如果你不访问这类属性，浏览器没有必要在这个点进行强制reflow，而可以等待到脚本执行完。现代浏览器的优化做得更好，所以类似的，如果你在append到document之后没有访问getComputedStyle之类的，浏览器也可以把样式表计算推迟到脚本执行之后。所以你测下来 append 到 document fragment 和直接 append 到 document 上就差不多了。尽管通常情况下，性能现在没有很大差异，但是作为靠谱程序员，你在追加dom时，用document fragement，是在代码层面明确：这里插入时，不需要（不应该）发生插入document的效果。所以该写的地方还是要写。<br><br><br>&gt; 回答2：早期，人们每次循环都把拼好的DIV  append到浏览器DOM中一个container里，比如JS写一个500次的循环，浏览器每次都执行重排，这样重排了500次。人们发现500次重排计算让浏览器做实在太耗费性能了。于是人们想，为什么不把这500个DIV以DOM的方式在内存里事先做好，然后一次append到浏览器里，这样浏览器一次处理的重排量虽然很大，但是比500次的小型重排的效率要快得多<br><br>&gt; 回答3：我记得在v8引擎优化之后 这些奇技淫巧往往会让实际速度变慢 （<font color="red">具体不知道真假）<br><br><br><br><br><br>=====================================================================================<br><br>#####<strong>PS:for循环应注意的问题</strong><br><br>&gt;如果您希望一遍又一遍地运行相同的代码，并且每次的值都不同，那么使用循环是很方便的。<br>很多时候我们都用到for循环，而用到for循环部门往往对一个数组进行循环，其中我们很多时候都是这样写的：<br><img src="./1502162693702.png" alt="Alt text"><br><br>　　这样的代码虽然没有什么大问题，但是每次循环都会获取一下数组的长度，这回降低你的代码，尤其当myarray不是数组，而是一个HTMLCollection对象的时候。<br>再看看下面的这个代码：<br><img src="./1502162739963.png" alt="Alt text"><br><br><br>这样地代码只会获取一次数组的长度，提高了代码的质量；<br>伴随着单var形式，你可以把变量从循环中提出来，就像下面这样：<br><img src="./1502162766604.png" alt="Alt text"><br><br><br>javascript使用for循环时问题总结<br>这个问题的讨论最初来自公司内部邮件，我只是把这个问题的讨论内容记录下来。<br>有一些项目组在定位问题的时候发现，在使用“for(x in array)”这样的写法的时候，在IE浏览器下，x出现了非预期的值。<br>具体说，如果自定义了Array.prototype.indexOf方法（譬如源于某prototype污染），也许是因为老版本IE浏览器并不支持array.indexOf方法，而开发者又很想用，那么这样的浏览器可能会出现这样的问题：<br><img src="./1502162788094.png" alt="Alt text"><br>输出:<br><img src="./1502162804098.png" alt="Alt text"><br><br>换句话说，把indexOf这个方法给输出出来了。<br>解决方法很简单，要么别添加这个方法，要么用“for (i=0; i &lt; array.length; i++)”这样的循环等等。<br>但是问题的本质呢？有人猜测，可能是因为for(x in obj)这种用法其实是去遍历一个对象，而array的实现其实也和普通的object一致，只不过key是既定的数值而已：<br><img src="./1502162833510.png" alt="Alt text"><br><br><br>在一则stackoverflow的问答里面也提到了，遍历数组的时候用for…in和for(;;)的区别，前者的含义是枚举对象的属性，存在这样两个问题：<br>枚举的顺序无法被保证；<br>继承属性也被枚举出来；<br>在对Array.prototype.forEach的支持上，从这张表中也可以明确看到，IE8及以下版本是无法准确支持的：<br><br><img src="./1502162865617.png" alt="Alt text"><br><br>这里还有对forEach方法兼容性的详细阐述。事实上，主要的JavaScript框架（比如jQuery、Underscore和Prototype等等）都有安全和通用的for-each功能实现。<br>在JSLint的for in章节里面也提到，for in语句允许循环遍历对象的属性名，但是也会遍历到那些通过原型链继承下来的属性，这在很多情况下都会造成预期以外的错误。有一种粗暴的解决办法：<br><img src="./1502162893891.png" alt="Alt text"><br><br><br>还有人提到了使用for(var i=0;i<length;i++)类似这样的循环时的问题，因为javascript没有代码块级别的变量，所以这里的i的访问权限其实是所在的方法。有x的书上会建议程序员把这样的变量声明放到一处去，但是从直观性上说，在大部分情况下都不够合理。 使用javascript="" 1.7中引入的“let”可以解决这个问题，使i成为真正的代码块级别的变量：="" ![alt="" text](.="" 1502162923177.png)="" 最后，在google的javascript风格导引里面，也涉及到了这个约束：="" 1502162936117.png)="====================================================================================" #####**原型对象汇总**="" 1.关于原型对象的重要知识点="" 首先要知道一个很重要的知识点,一句话:所有对象都有原型对象.="" 2.="" 对比其他语言的理解="" 原型对象,就是其它语言中的类中的静态属性和静态方法,总是是静态-static就对了.原理是:="" 内存中只有一份.="" 3.="" 在内存中的形象图:="" 首先,在产生js对象之前,我们需要创造一个构造函数(这都不知道,那就不要往下看了),如下:="" <figure="" class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name_, age_</span>) &amp;#123;</span></span><br><span class="line"><span class="function">         <span class="title">this</span>.<span class="title">name</span> = <span class="title">name_</span>;</span></span><br><span class="line"><span class="function">         <span class="title">this</span>.<span class="title">age</span> = <span class="title">age_</span>;</span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br></pre></td></tr></table><br><br>下面,我们就要new 对象了,这里,我们new三个(Person)对象,”张三” “李雷” “韩梅梅”,他们来自同一个构造函数Person:<br><br><img src="./1502163550506.png" alt="Alt text"><br><br><br><br><br>内存中就这样了,每个对象,都有自己的 name, age 内存.这里new了多少个对象,就要开辟多少块name, age内存.<br><br>看到这,应该还是比较好理解的. 下面我们添加一条属性.location属性,如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name_, age_</span>) &amp;#123;</span></span><br><span class="line"><span class="function"><span class="title">this</span>.<span class="title">name</span> = <span class="title">name_</span>;</span></span><br><span class="line"><span class="function"><span class="title">this</span>.<span class="title">age</span> = <span class="title">age_</span>;</span></span><br><span class="line"><span class="function"><span class="title">this</span>.<span class="title">location</span> = "地球";</span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br></pre></td></tr></table></figure><br><br>这时候 我们在new这三个人. 内存情况如下:<br><img src="./1502163575063.png" alt="Alt text"><br><br><br>这里我们看,三个对象都有一个”地球”的内存空间.  这里你要动动大脑了, 三个人都有地球的内存,我们是不是可以这样呢?<br><br>你看这样好不好呢?  这样只需要一个地球,大家都可以用了.   看到这,好吧,公用的那个空间如果是个对象的话,就是所谓的原型对象了.就这样?<br>是的,就这样.<br><br>原型对象,最重要的作用就是把常量和方法独立到自身里.   供给其它 “自己的对象” 使用. 最后如图:<br><br> <img src="./1502163597440.png" alt="Alt text"><br><br><br>4. 从代码的层次上介绍原型对象.<br>上图是内存中的对象,我们现在从代码的从面操作.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name_, age_</span>) &amp;#123;</span></span><br><span class="line"><span class="function"><span class="title">this</span>.<span class="title">name</span> = <span class="title">name_</span>;</span></span><br><span class="line"><span class="function"><span class="title">this</span>.<span class="title">age</span> = <span class="title">age_</span>;</span></span><br><span class="line"><span class="function"><span class="title">this</span>.<span class="title">location</span> = "地球";</span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line"><span class="function">//  三个具体的对象</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">zhangsan</span> = <span class="title">new</span> <span class="title">Person</span>(<span class="params"><span class="string">"zhangsan"</span>, <span class="number">21</span></span>);</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">lilei</span> = <span class="title">new</span> <span class="title">Person</span>(<span class="params"><span class="string">"lilei"</span>, <span class="number">21</span></span>);</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">hanmeimei</span> = <span class="title">new</span> <span class="title">Person</span>(<span class="params"><span class="string">"hanmeimei"</span>, <span class="number">21</span></span>);</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">// 他们的原型对象是</span></span><br><span class="line"><span class="function"><span class="title">Person</span>.<span class="title">prototype</span>.<span class="title">location</span> = "地球";</span></span><br><span class="line"><span class="function"><span class="title">Person</span>.<span class="title">prototype</span>.<span class="title">killPerson</span> = <span class="title">function</span>(<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function">                                               <span class="title">return</span> "杀人";</span></span><br><span class="line"><span class="function">                                       &amp;#125;;</span></span><br></pre></td></tr></table></figure><br><br>这里有一个问题,我们知道原型对象,可是我们怎么访问到原型对象里的属性呢.  就是我们如何获取到location ,和用 killPerson方法呢?<br>请看:<br>         alert(zhangsan.location);<br>         alert(zhangsan.killPerson());<br><br>这样就可以访问到了,不过前提是,你的对象属性里面,没有定义location和killPerson.不然会把原对象的覆盖掉.   这里面涉及到原型问题即,<br>在zhangsan.location的时候,首先,我们检查zhangsan对象本身,从图中我们知道,张三有 name, age 和prototype指针属性.  并没有location,找不到以后,它会继续搜索原对象里面,看能否找到location属性,如果有,就会调用原对象的属性.<br><br>所以alert(zhangsan.location) 会输出   “地球”<br>alert(zhangsan.killPerson() ) 会输出   “杀人”<br><br><br><br><br><br><br><br><br>理解js的prototype原型对象<br>我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原受对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示。<br><img src="./1502163624964.png" alt="Alt text"><br><br><br><br>在此，我们将sayName()方法和所有属性直接添加到了Person的prototype属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说．personl和person2访问的都是同一组属性和同一个sayName()函数。要理解原型模式的T作原理，必须先理解ECMAScript巾原型对象的性质。<br><br>理解原型对象<br><br>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prot otype属性所在函数的指针。就拿前面的例子来说，Person.prototype. constructor措向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。<br>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Obj ect继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含—个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype】]。虽然在脚本中没有标准的方式访问【[ Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性—proto<em>;而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。<br>以前面使用Person构造函数和Person.prototype创建实例的代码为例，图6-1展示了各个对象之间的关系。<br> <img src="./1502163648019.png" alt="Alt text"><br><br><br><br><br><br><br><br>上图展示rr Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。在此，Person <em>prototype指向了原型对象，而Person.prototype.constructor叉指回了Person。原型对象中除了包含cons t,ruct or属性之外，还包括后来添加的其他属性。Person的每个实例personl和person2都包含一个内部属性，该属性仅仅指向了Person.prot otype;换句话说，它们与构造函数没有直接的关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用personl.sayName()。这是通过查找对象属性的过程来实现的。<br>虽然在所有实现中都无法访问到[[Prototype]：，但可以通过isProcotypeOf()方法来确定对象之间是否存在这种关系。从本质上讲，如果[[ Prototype]]指向调用isPrototypeOf()方法的对象[Person.prototype)．那么这个方法就返回true，如下所示：<br> <img src="./1502163666738.png" alt="Alt text"><br><br><br><br><br>这里，我们用原型对象的isPrototypeOf()方法测试了personl和person2 0因为它们内部都有一个指向Person.prototype的指针，因此都返回了true。<br><br>ECMAScript 5增加了一个新方法，叫Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[PrototypeJ]]的值。例如：<br> <img src="./1502163682791.png" alt="Alt text"><br><br><br><br>这里的第一行代码只是确定Object.getPrototypeOf()返回的对象实际就是这个对象的原型。第二行代码取得了原型对象中name属性的值，也就是’Nicholas’。使用Object.getPrototypeOf()可以方便地取得一个对象的原型，而这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的。支持这个方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera 12+和Chrome。<br>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用personl. sayName《）的时候，会先后执行两次搜索。首先，解析器会同：“实例personl有sayName属性吗？”答：“没有。”然后，它继续搜索，再问：“personl的原捌有sayName属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函数。当我们调用person2.sayName()时，将会重现相同的搜索过程，得到相同的结果。而这正是多个对象实例共享原型所保存的属性和方法的基本原理。<img src="./clipboard.png" alt="Alt text"><br><br>=====================================================================================<br><br><br><br>#####<strong>对象直接量</strong><br><br>&gt;对象直接量提供了另一种创建新对象的方式。对象直接量允许将对象描述文字嵌入到JavaScript代码中，就像将文本数据嵌入在JavaScript代码中，就像将文本数据嵌入在JavaScript代码中作为引用的字符串一样。对象直接量是由属性说明列表构成的，这个列<br>表包含在大括号之中，其中的属性说明用逗号隔开。对象直接量中的每个属性说明列表都由一个属性名及跟在其后的冒号和属性值构<br>成。使用对象直接量创建对象的一般格式如下：<br>var myobject = &#123;属性名1:属性值1,属性2:属性值,…,属性名n:属性值n&#125;<br>       从这个定义中可以看出，这种定义方式实际上是声明一种类型的变量，并同时进行了赋值。因此，声明后的对象直接量可以<br>在代码中直接使用，而不必使用new关键字来创建对象。<br>此种方法只是创建了该对象的一个实例，如果要创建该对象的多个实例，需要将对象直接量写多遍。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var circle = &amp;#123;</span><br><span class="line"><span class="string">"x"</span>:<span class="number">0</span>,</span><br><span class="line">y:<span class="number">0</span>,</span><br><span class="line">radius:<span class="number">2</span>,</span><br><span class="line">alerttest:<span class="function"><span class="keyword">function</span>(<span class="params">mm</span>)&amp;#123;<span class="title">alert</span>(<span class="params">mm</span>);&amp;#125;,</span></span><br><span class="line"><span class="function"><span class="title">birthday</span>:</span></span><br><span class="line"><span class="function">  &amp;#123;<span class="title">year</span>:'1982年',<span class="title">month</span>:'2月',<span class="title">day</span>:'14日'&amp;#125;</span></span><br><span class="line"><span class="function">&amp;#125; </span></span><br><span class="line"><span class="function"><span class="title">document</span>.<span class="title">write</span>(<span class="params">circle.x + <span class="string">" "</span> + circle[<span class="string">"y"</span>] + <span class="string">" "</span> + circle.radius</span>); </span></span><br><span class="line"><span class="function"><span class="title">circle</span>.<span class="title">alerttest</span>(<span class="params"><span class="string">"elong"</span></span>);</span></span><br></pre></td></tr></table></figure><br><br>&gt;对象直接量和json，有人可以转换等等。 我经过测试，感觉现在浏览器已经爸他们当作一回事了。<br><br>&gt;最近研究一个fck时，发现在js的多语言实现时用到了直接量。<br><br>&gt;仔细一想真是聪明之极。<br>1.直接量有点想数组，key–value的形式组织。<br>2.当直接具体那个key时可以这样得到值：circle .key, 或者circle[“key”]. 前一种方式我更喜欢<br>3.当程序动态的取值时：circle[key].    key可以动态传入。<br><br><br>=====================================================================================<br><br><br>#####<strong>栈内存和堆内存</strong><br>JS中栈内存和堆内存的区别：<br><br><br> 堆和栈这两个字我们已经接触多很多次，那么具体是什么存在栈中什么存在堆中呢？就拿JavaScript中的变量来说：<br>         首先JavaScript中的变量分为基本类型和引用类型。<br>         基本类型就是保存在栈内存中的简单数据段，而引用类型指的是那些保存在堆内存中的对象。<br><br>1、基本类型<br>         基本类型有Undefined、Null、Boolean、Number 和String。这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。<br><br>2、引用类型<br>          引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。如下图所示：栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。由于这种值的大小不固定，因此不能把它们保存到栈内存中。但内存地址大小的固定的，因此可以将内存地址保存在栈内存中。 这样，当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。<br><br><img src="./1502165642601.png" alt="Alt text"><br><br><br>其他语言中的内存分配类似。<br>     PS：当我们看到一个变量类型是已知的，就分配在栈里面，比如INT,Double等。其他未知的类型，比如自定义的类型，因为系统不知道需要多大，所以程序自己申请，这样就分配在堆里面。<br><img src="./1502165669503.png" alt="Alt text"><br><br><br><br>为什么会有栈内存和堆内存之分？<br>     通常与垃圾回收机制有关。为了使程序运行时占用的内存最小。<br>     当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；<br>     当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。<br><br><br><br><br><br>由于Javascript是松散型的，所以其变量只是在特定时间用于保存特定值的一个名字而已，并不存在某个变量必须保存某种类型的值的规则，变量的值以及其数据类型都可以在脚本的声明周期内改变<br>一、基本类型与引用类型<br>　　1.1 基本类型：保存在栈内存中的简单数据段，值保存在内存中的一个位置<br>　　1.2 引用类型：保存在堆内存中的对象，变量保存的仅仅是一个指针，这个指针指向内存中的另一个位置，该位置保存对象<br>　　　　1.2.1 5种基本数据类型：Undefined、Null、Boolean、Number、String在内存中分别占有固定大小的空间，保存在栈内存中<br>　　　　1.2.2 按值访问：对于保存基本数据类型的变量，我们操作的是它们实际保存的值<br>　　　　1.2.3 引用类型的值由于大小不固定，因此保存在堆内存中，但存放引用类型值的堆内存的内存地址大小是固定的，因此我们将这个地址保存在栈内存中，当操作引用类型的值时，先到栈内存　　　　　　　　读取该引用类型值的堆内存地址，然后在找到保存在堆内存中的引用类型的值<br>　　　　1.2.4 按引用访问：因为我们操作的不是实际的值，而是被这个值所引用的对象<br>　　　　1.2.5 保存在栈内存中的每个值分别占据固定大小的空间，因此可以按照顺序来访问<br>　　　　　　<br><img src="./1502165692819.png" alt="Alt text"><br><br>　　1.3 动态属性：只能给引用类型值动态的添加属性<br>　　1.4 复制变量值：针对基本数据类型值的复制，会在栈中创建一个新值，然后把该值复制到为新变量分配的位置上<br>　　　　针对引用类型值时，复制的只是一个指针，复制操作结束后，两个变量实际上将引用同一个对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> num2=num1;</span><br><span class="line">num1=<span class="number">6</span>;</span><br><span class="line">alert(num2);<span class="comment">//5</span></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="keyword">var</span> obj1=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj2=obj1;</span><br><span class="line">obj1.name=<span class="string">"Jim"</span>;</span><br><span class="line">alert(obj2.name);<span class="comment">//"Jim"</span></span><br></pre></td></tr></table></figure><br><br><img src="./1502165707301.png" alt="Alt text"><br><br><br><br>　<font color="red" size="5">1.5 传递参数：所有的参数传递全部是按值传递，虽然访问变量的时候有按值和按引用两种方式，但是参数传递只能按值传递。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，这个变量的变化不会反映在函数外面<br>　</font><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)&amp;#123;传递的时候应该是<span class="title">obj</span>=<span class="title">p</span>，<span class="title">obj</span>此时存的是<span class="title">p</span>中的地址</span></span><br><span class="line"><span class="function">    <span class="title">obj</span>.<span class="title">name</span>="<span class="title">Jim</span>";  --&gt;把<span class="title">obj</span>指向的对象添加一个键值对<span class="title">name</span>：“<span class="title">jim</span>”；</span></span><br><span class="line"><span class="function">    <span class="title">obj</span>=<span class="title">new</span> <span class="title">Object</span>(<span class="params"></span>);--&gt;<span class="title">new</span> <span class="title">Object</span>（）创建一个新的对象把新对象的地址赋给<span class="title">obj</span>，此时<span class="title">obj</span>的地址不再是<span class="title">p</span>的地址</span></span><br><span class="line"><span class="function">    <span class="title">obj</span>.<span class="title">name</span>="<span class="title">Greg</span>";  --&gt;给新的对象内存中添加一个键值对<span class="title">name</span>：<span class="title">Greg</span>；                             </span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">p</span>=<span class="title">new</span> <span class="title">Object</span>(<span class="params"></span>);//<span class="title">p</span>存储一个地址<span class="title">xxxfff000</span></span></span><br><span class="line"><span class="function"><span class="title">setName</span>(<span class="params">p</span>);</span></span><br><span class="line"><span class="function"><span class="title">alert</span>(<span class="params">p.name</span>);//"<span class="title">Jim</span>"</span></span><br><span class="line"><span class="function">//如果是按引用传递的话，那么<span class="title">p</span>就会被自动修改为指向其<span class="title">name</span>属性为”<span class="title">Greg</span>“的新对象，但是由下图分析可知，参数传递是按值传递</span></span><br></pre></td></tr></table></figure><br><br><img src="./1502165783773.png" alt="Alt text"><br><br>　　1.6 检测类型：typeof操作符是确定一个变量是字符串、数值、布尔、还是undefined，以及object的最佳工具，但是对于一个对象或者null，却只能返回”object”,因此在检测引用类型值的时候，引入了instanceof操作符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Name</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">p</span>=<span class="title">new</span> <span class="title">Name</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function"><span class="title">alert</span>(<span class="params">p instanceof Name</span>);//<span class="title">true</span></span></span><br></pre></td></tr></table></figure><br><br>二、执行环境和作用域<br>　　2.1 执行环境定义了变量和函数有权访问的其他数据，每个执行环境都有一个变量对象，环境中的所有变量和函数都保存在这个对象中，我们编写的代码无法访问这个对象<br>　　2.2 全局执行环境：最外围的一个执行环境，在web浏览器中，全局执行环境是window对象，因此全局变量和函数都作为window对象的属性和方法创建的<br>　　2.3 当某个执行环境的所有代码执行完毕后，该环境会被销毁，保存在其中的变量和函数也会被销毁<br>　　2.4 全局执行环境的销毁是在关闭网页或者浏览器时<br>　　2.5 每个函数都有自己的执行环境，当执行到某个函数时，会把控制权交给该函数，直到该函数执行完毕后，再把控制权交给之前的环境<br>　　2.6 当代码在一个环境(例如一个函数)中执行时，会创建变量对象的作用域链<br>　　2.7 作用域链的作用是保证对执行环境中的变量和函数的有序访问<br>　　2.8 作用域链的前端始终是当前代码的执行环境的变量对象<br> 　　2.9 如果执行环境是函数，那么变量对象是活动对象，初始只包含一个变量arguments对象，外层是包含该环境的环境，外层的外层是包含该环境的环境的环境，一直延伸到全局执行环境<br>　　2.10 全局执行环境始终是作用域链的最后一个对象<br>　　2.11 在搜索某个标识符(如变量名，函数名等)时，会沿着作用域链一级一级的搜索，直到找到，搜索停止，这也就达到了2.7中提到的作用域链的作用(保证对执行环境中的变量和函数的有序访问)<br><br><br><img src="./1502165807040.png" alt="Alt text"><br><br>　　2.12 内部环境可以通过作用域链一级一级访问都所有外部的变量以及函数，包括最外层的全局执行环境，但是外部环境却不能访问内部环境的变量和函数，作用域链只能从下向上搜索，不能从上向下搜索<br>　　2.13 例如swap函数可以访问全局变量color，但是全局变量window却不能访问到another或者temp<br>　　2.14 延长作用域链的方式：第一try-catch语句中的catch块，第二with语句，这两个语句都会在作用域链的前端添加一个变量对象，对于with语句来说，其变量对象中包含着为指定对象的所有属性和方法所作的变量声明。对于catch语句来时，其变量对象中包含的是被抛出的错误对象的声明，这些变量对象是只读的<br>　　2.15 浏览器的兼容性问题1注意IE与标准在try-catch语句延长作用域链的不同之处：即使在catch块的外部也可以访问到错误对象<br>　　2.16 js没有块级作用域的概念，所谓块级作用域就是由花括号封闭的代码块都有自己的作用域，但是js中使用var声明的变量，会被自动添加到距离最近的可用的执行环境中，未使用var声明被初始化的变量，会被自动添加到全局环境，其作用范围跟花括号没有关系<br>　　2.17 查询标识符时也会根据作用域链，从下向上一级一级进行搜索，搜索到后，就停止，因此，如果局部环境存在同名的标识符，就不会使用父环境中的标识符<br>三、垃圾收集机制<br>　　3.1 js具有自动垃圾收集机制，垃圾收集器会按照固定的时间间隔周期性地执行这一操作，两种方式：标记清除和引用计数<br>　　3.2 标记清除：js中最常用的垃圾收集方式，当执行流进入到相应的环境(即当执行流调用某个函数)时，该函数中声明了某个变量，那么这个变量就被标记为“进入环境”，从逻辑上讲，永远不能释放进入环境的变量的内存，当变量离开环境时，则被标记为“离开环境”。可利用翻转某个特殊的位来记录<br>　　3.3 引用计数：跟踪记录每个值被引用的次数，将一个引用类型的值赋值给一个变量，那么这个引用类型的值的引用次数就加1，相反，如果这个变量被赋值了其他值，这个引用类型的值的引用次数就减1，当引用次数为0时，就说明没有办法再访问这个引用类型的值了，那么她所占的内存空间会被垃圾回收器给回收<br>　　3.4 循环引用：如果对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的指针，就形成了循环引用，它们的引用次数永远不会为0，为了避免循环引用问题，最好是在不使用它们的时候，手工断开它们之间的连接<br>　　3.5 内存限制问题：js中分配给web浏览器的可用内存数量通常比分配给桌面应用程序的少，原因是为了防止运行js的网页耗尽全部内存而导致系统崩溃<br>　　3.6 解除引用：由于内存的限制，所以我们要优化内存占用，最佳策略就是执行代码只保存必要的数据，一旦数据不再用，最好通过将其值设置为null来释放对其的引用，这种方法称为解除引用<br>　　3.7 解除引用的适用范围：解除引用适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时自动被解除引用<br>　　3.8 对解除引用需要声明的一点：解除引用并不代表收回该值所占的内存，解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其收回<br><br><br><br><br>   栈内存和堆内存实例：<br><br>js中如果创建两个个对象p1,p2，使用p1为p2赋值会怎样？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"> </span><br><span class="line">p1.name = ‘zhangsan’;</span><br><span class="line"> </span><br><span class="line">p1.age = <span class="number">30</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> p2 = p1;</span><br></pre></td></tr></table></figure><br><br>这时，p1和p2会指向同一内存<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line"><span class="function">   &amp;#125;</span></span><br><span class="line"><span class="function">       <span class="title">var</span> <span class="title">p1</span> = <span class="title">new</span> <span class="title">person</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function">       <span class="title">p1</span>.<span class="title">name</span>= '<span class="title">zhangshan</span>';</span></span><br><span class="line"><span class="function">       </span></span><br><span class="line"><span class="function">       <span class="title">var</span> <span class="title">p2</span>= <span class="title">p1</span>;//对象之间赋值，现在<span class="title">p1</span> 和 <span class="title">p2</span>指向的是同一个内存空间</span></span><br><span class="line"><span class="function">   　　  //  <span class="title">alert</span>(<span class="params">p2.name</span>);</span></span><br><span class="line"><span class="function">　　　　<span class="title">var</span> <span class="title">p2</span> = '<span class="title">apple</span>';　//将<span class="title">p2</span>的值发生改变会影响<span class="title">p1</span>的值　</span></span><br><span class="line"><span class="function">　　　　//  <span class="title">alert</span>(<span class="params">p1.name</span>);</span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">   <span class="title">p2</span> = <span class="title">null</span> ;//这里是指将<span class="title">p2</span>的栈内存清除了，但是<span class="title">p2</span>指向的堆内存还是存在！</span></span><br><span class="line"><span class="function">//   <span class="title">alert</span>(<span class="params">p2.name</span>);</span></span><br><span class="line"><span class="function">   <span class="title">alert</span>(<span class="params">p1.name</span>);//所以这里可以输出结果！</span></span><br></pre></td></tr></table></figure><br><br><br><br>栈（操作系统）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈<br><br>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放<br><br>堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。<br><br>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些<br><br>堆（数据结构）：堆可以被看成是一棵树，如：堆排序<br><br>栈（数据结构）：一种后进先出的的数据结构<br><br><br>堆和栈的区别可以用如下的比喻来看出：<br>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。<br>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。<br><br><br><br><br>=====================================================================================<br><br><br>#####<strong>关于阻止a标签的默认行为</strong><br><br>&gt;以下简单总结以下a标签阻止默认行为的几种简单方法，希望可以对有需要的朋友有些帮助，<br>(1)   <a href="javascript:void(0);" onclick="myjs( )" target="_blank" rel="noopener">  Click Me  </a><br>onclick方法负责执行js函数，而void是一个操作符，void(0)返回undefined，地址不发生跳转。<br><a href="javascript:;" target="_blank" rel="noopener">  Click Me  </a><br>和void(0)一样，都返回”undefined”<br><br>&gt;(2) <a href="#">  Click Me   </a><br>是网上很常见的代码，#是标签内置的一个方法，用这种方法点击后网页后返回到页面的最顶端所以又有了“##”“#!”等,尽管解决了返回顶部的问题但仍存在其他缺陷<br><br>&gt;(3)事件处理函数的工作机制中，在给某元素添加事件处理函数后，一旦事件发生，相应JavaScript代码就会执行，所调用的JavaScript代码的返回值被传递给事件处理函数。当我们给a标签添加onclick事件处理函数并点击a触发其后，<br>如果相应JavaScript代码返回true，onclick事件处理函数就会认为这个链接呗点击了，同样的若返回false即会认为链接<br>未被点击<br><a href="http://www.baidu.com" onclick=" myjs(); return false; " target="_blank" rel="noopener">   Click Me   </a><br><a href="http://www.baidu.com" onclick=" return false; " target="_blank" rel="noopener">  Click Me  </a><br>当点击a标签时，JavaScript代码返回值为false，故此链接默认行为未被触发。<br><br>&gt;(4)preventDefault()阻止事件的默认行为但不支持IE，所以在IE中使用returnValue阻止事件默认行为<br><a href="http://www.baidu.com" id="test" target="_blank" rel="noopener">  Click Me  </a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopDefault</span>(<span class="params"> e </span>)</span></span><br><span class="line"><span class="function">&amp;#123; </span></span><br><span class="line"><span class="function">   <span class="title">if</span> (<span class="params"> e &amp;&amp; e.preventDefault </span>) </span></span><br><span class="line"><span class="function">      <span class="title">e</span>.<span class="title">preventDefault</span>(<span class="params"></span>); </span></span><br><span class="line"><span class="function">     <span class="title">else</span> </span></span><br><span class="line"><span class="function">        <span class="title">window</span>.<span class="title">event</span>.<span class="title">returnValue</span> = <span class="title">false</span>;  </span></span><br><span class="line"><span class="function">&amp;#125; </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">test</span>.<span class="title">onclick</span> = <span class="title">function</span>(<span class="params">e</span>) </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&amp;#123; </span></span><br><span class="line"><span class="function">     <span class="title">stopDefault</span>(<span class="params">e</span>); </span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br></pre></td></tr></table></figure><br><br>================================================================================<br><br>#####<strong>PS：innerText和innerHTML</strong><br> document 对象中有innerHTML和innerText 两个属性， 这两个属性都是获取document对象的文本内容的，这两个属性间有哪些区别呢？通过几个例子来看一下。<br><br>示例1<br>  1. <html><br>  2.     <head><title>innerHTML</title></head><br>  3.     <body><br>  4.         <p id="p1">hello world </p><br>  5.         <script><br>  6.             var content = document.getElementById(“p1”);<br>  7.             alert(content.innerHTML);<br>  8.             alert(content.innerText)<br>  9.         </script><br>  10.     </body><br>  11. </html><br>通过IE浏览器打开，弹出内容为 “hello world” 和 “hello world”<br>通过 Firefox 浏览器打开，弹出内容为 “hello world” 和 “undefined”<br>通过 chrome 浏览器打开，弹出内容为 “hello world” 和 “hello world”<br><br>示例2<br><br>   <html><br>   <head><title>innerHTML</title></head><br>    <body><br>       <div id="d1"><p id="p1">hello world </p></div><br>         <script><br>           var content = document.getElementById(“d1”);<br>          alert(content.innerHTML);<br>      alert(content.innerText)<br>        </script><br>     </body><br>  </html><br>通过IE浏览器打开，弹出内容为 <p id="p1">hello world </p> 和 hello world<br>通过 Firefox 浏览器打开，弹出内容为 <p id="p1">hello world </p> 和 undefined<br>通过 chrome 浏览器打开，弹出内容为 <p id="p1">hello world </p> 和 hello world<br><br><br>通过上面两个示例，可以看出：<br>innerHTML指的是从对象的起始位置到终止位置的全部内容,包括Html标签。<br>innerText   指的是从起始位置到终止位置的内容,但它去除Html标签。<br>同时，innerHTML 是所有浏览器都支持的，innerText 是IE浏览器和chrome 浏览器支持的，Firefox浏览器不支持。其实，innerHTML 是W3C 组织规定的属性；而innerText 属性是IE浏览器自己的属性，不过后来的浏览器部分实现这个属性罢了。<br><br>outerHTML<br><br>说到innerHTML，顺便说一下跟innerHTML相对的outerHTML属性。<br><br>继续看上面的代码，将alert(content.innerText) 修改为 alert(content.outerHTML)<br><br> 通过浏览器可以看到弹出框为<p id="p1">hello world </p><br>和 <divid="d1"><p id="p1">hello world</p><br><br>outerHTML指的是除了包含innerHTML的全部内容外, 还包含对象标签本身。<br><br><br>总结说明<br><br>　　innerHTML是符合W3C标准的属性，而innerText只适用于IE浏览器（现在也适应chrome浏览器），因此，尽可能地去使用 innerHTML，而少用innerText，如果要输出不含HTML标签的内容，可以使用innerHTML取得包含HTML标签的内容后，再用正则表达式去除HTML标签，下面是一个简单的符合W3C标准的示例：<br><br><br><br>弹出的为去掉了html标签之后的内容，这是个在所有浏览器均可使用的方法。<br><br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> &lt;html&gt;  </span><br><span class="line"><span class="number">2.</span>     &lt;head&gt;&lt;title&gt;innerHTML&lt;/title&gt;&lt;/head&gt;  </span><br><span class="line"><span class="number">3.</span>     &lt;body&gt;  </span><br><span class="line"><span class="number">4.</span>         &lt;div id=<span class="string">"d1"</span>&gt;&lt;p id="p1"&gt;hello world &lt;/p&gt;&lt;/div&gt;  </span><br><span class="line"><span class="number">5.</span>         &lt;script&gt;  </span><br><span class="line"><span class="number">6.</span>             <span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);  </span><br><span class="line"><span class="number">7.</span>             alert(content.innerHTML.replace(<span class="regexp">/&amp; lt;.+?&gt;/gim</span>,<span class="string">''</span>));  </span><br><span class="line"><span class="number">8.</span>         &lt;<span class="regexp">/script&gt;  </span></span><br><span class="line"><span class="regexp">9.     &lt;/</span>body&gt;  </span><br><span class="line"><span class="number">10.</span> &lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><br><br>innerHTML和innerText的区别：<br>1innerHTML插入内容的时候，浏览器会把插入内容中的HTML标签字符最后识别为正常的标签，而innerText不管写的是什么，最后浏览器都会识别为普通的文本。<br><br><br><br><br><br><br>============================================================================<br><br>#####<strong>PS:关于函数的低耦合和高内聚</strong><br><br><br>   起因：模块独立性指每个模块只完成系统要求的独立子功能，并且与其他模块的联系最少且接口简单，两个定性的度量标准――耦合性和内聚性。<br><br>    耦合性也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。<br>    耦合性分类(低――高): 无直接耦合;数据耦合;标记耦合;控制耦合;公共耦合;内容耦合;<br>1 无直接耦合:<br>2 数据耦合: 指两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言的值传递;<br>3 标记耦合: 指两个模块之间传递的是数据结构，如高级语言中的数组名、记录名、文件名等这些名字即标记，其实传递的是这个数据结构的地址;<br>4 控制耦合: 指一个模块调用另一个模块时，传递的是控制变量（如开关、标志等），被调模块通过该控制变量的值有选择地执行块内某一功能;<br>5 公共耦合: 指通过一个公共数据环境相互作用的那些模块间的耦合。公共耦合的复杂程序随耦合模块的个数增加而增加。<br>6 内容耦合: 这是最高程度的耦合，也是最差的耦合。当一个模块直接使用另一个模块的内部数据，或通过非正常入口而转入另一个模块内部。<br><br>    内聚性又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。<br>    内聚性匪类(低――高): 偶然内聚;逻辑内聚;时间内聚;通信内聚;顺序内聚;功能内聚;<br>1 偶然内聚: 指一个模块内的各处理元素之间没有任何联系。<br>2 逻辑内聚: 指模块内执行几个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。<br>3 时间内聚: 把需要同时执行的动作组合在一起形成的模块为时间内聚模块。<br>4 通信内聚: 指模块内所有处理元素都在同一个数据结构上操作（有时称之为信息内聚），或者指各处理使用相同的输入数据或者产生相同的输出数据。<br>5 顺序内聚: 指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素输出就是下一功能元素的输入。<br>6 功能内聚: 这是最强的内聚，指模块内所有元素共同完成一个功能，缺一不可。与其他模块的耦合是最弱的。<br><br>    耦合性与内聚性是模块独立性的两个定性标准，将软件系统划分模块时，尽量做到高内聚低耦合，提高模块的独立性，为设计高质量的软件结构奠定基础。<br><br>    有个例子很容易明白：一个程序有50个函数，这个程序执行得非常好；然而一旦你修改其中一个函数，其他49个函数都需要做修改，这就是高耦合的后果。<br>一旦你理解了它，你编写概要设计的时候设计类或者模块自然会考虑到“高内聚，低耦合”。<br><br><br>=====================================================================================<br><br>#####<strong>PS：使用JS获取当前元素的index值</strong><br><br><br><br>在之前面试的时候，笔记的环节总是碰到用原生js弹出当前点击li的indx值，今天没事就写一下，留作记忆！<br>下面是html机构，为了省事我就不加id class了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br>接下来就是js部分了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list =<span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line">for(var i=0;i&lt;list.length;i++)&amp;#123;</span><br><span class="line">	list[i].index=i;</span><br><span class="line">	list[i].onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function">		<span class="title">alert</span>(<span class="params">this.index+<span class="number">1</span></span>);                  //加不加1随你了！</span></span><br><span class="line"><span class="function">	&amp;#125; </span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br></pre></td></tr></table></figure><br><br>如果你把js代码放到了头部，一定要记得加window.onload=function()&#123;&#125;<br><br>放到头部，不加这段代码的话会点击没有反应，或者直接报错：<br>Uncaught TypeError: Cannot set property ‘onclick’ of null;<br>后来在stackoverflow 找到了原因。要是对DOM操作的话，要先加载完全。扯的有点远了啊！<br>接下换一个写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list =<span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line">				for(var i=0;i&lt;list.length;i++)&amp;#123;</span><br><span class="line">					list[i].onclick =	(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)&amp;#123;</span></span><br><span class="line"><span class="function">						<span class="title">return</span> <span class="title">function</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line"><span class="function">							<span class="title">alert</span>(<span class="params">n</span>);</span></span><br><span class="line"><span class="function">						&amp;#125;</span></span><br><span class="line"><span class="function">					&amp;#125;)(<span class="params">i</span>)</span></span><br><span class="line"><span class="function">	  		&amp;#125;</span></span><br><span class="line"><span class="function">	  	&amp;#125;</span></span><br></pre></td></tr></table></figure><br><br>最后附上完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">	&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">		li&amp;#123;</span><br><span class="line">			background-color: red;</span><br><span class="line">		&amp;#125;</span><br><span class="line">	&lt;/style&gt;</span><br><span class="line">	&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">		window.onload=function()&amp;#123;</span><br><span class="line">			</span><br><span class="line">			var list =document.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">				for(var i=0;i&lt;list.length;i++)&amp;#123;</span><br><span class="line">					list[i].onclick =	(function(n)&amp;#123;</span><br><span class="line">						return function()&amp;#123;</span><br><span class="line">							alert(n);</span><br><span class="line">						&amp;#125;</span><br><span class="line">					&amp;#125;)(i)</span><br><span class="line">	  		&amp;#125;</span><br><span class="line">	  	&amp;#125;</span><br><span class="line">  	&amp;#125;</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;ul&gt;</span><br><span class="line">		&lt;li&gt;1&lt;/li&gt;</span><br><span class="line">		&lt;li&gt;2&lt;/li&gt;</span><br><span class="line">		&lt;li&gt;3&lt;/li&gt;</span><br><span class="line">		&lt;li&gt;4&lt;/li&gt;</span><br><span class="line">		&lt;li&gt;5&lt;/li&gt;</span><br><span class="line">	&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br><br>=====================================================================================<br><br>#####<strong>alert输出对象的问题</strong><br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&amp;#123;name:'xxx'&amp;#125;)；//-&gt; '[Object,Object]' 两个大写Object</span><br></pre></td></tr></table></figure><br><br><img src="./1502166964946.png" alt="Alt text"><br><br><br><br><br><br><br><br><br><br>#####<strong>console的强大</strong><br><br><br>&gt;写在前面<br>大家都有用过各种类型的浏览器，每种浏览器都有自己的特色，本人拙见，在我用过的浏览器当中，我是最喜欢Chrome的，因为它对于调试脚本及前端设计调试都有它比其它浏览器有过之而无不及的地方。可能大家对console.log会有一定的了解，心里难免会想调试的时候用alert不就行了，干嘛还要用console.log这么一长串的字符串来替代alert输出信息呢，下面我就介绍一些调试的入门技巧，让你爱上console.log<br>先的简单介绍一下chrome的控制台，打开chrome浏览器，按f12就可以轻松的打开控制台<br><br><img src="./1502172057370.png" alt="Alt text"><br><br>&gt; 大家可以看到控制台里面有一首诗还有其它信息，如果想清空控制台，可以点击左上角那个<br> <img src="./1502172127554.png" alt="Alt text"><br><br>&gt;来清空，当然也可以通过在控制台输入console.clear()来实现清空控制台信息。如下图所示<br>&gt;<img src="./1502172156876.png" alt="Alt text"><br>现在假设一个场景，如果一个数组里面有成百上千的元素，但是你想知道每个元素具体的值，这时候想想如果你用alert那将是多惨的一件事情，因为alert阻断线程运行，你不点击alert框的确定按钮下一个alert就不会出现。<br>&gt; 下面我们用console.log来替换，感受一下它的魅力。<br><img src="./1502172189283.png" alt="Alt text"><br><br><br>&gt;看了上面这张图，是不是认识到log的强大之处了，下面我们来看看console里面具体提供了哪些方法可以供我们平时调试时使用。<br>&gt;<img src="./1502172243456.png" alt="Alt text"><br><br><br>&gt;1、先说一下源码定位<br>    大家打开测试网页   看到页面右下方有一个推荐的图标吗？右击推荐图标，选择审查元素，打开谷歌控制台，如下图所示<br><img src="./1502172284025.png" alt="Alt text"><br><br>&gt;我们现在想知道votePost方法到底在哪？跟着我这样做，在Console面板里面输入votePost然后回车<br><img src="./1502172313643.png" alt="Alt text"><br>&gt;直接点击上图标红的链接，控制台将定位到Sources面板中，展示如下图所示<br>&gt;<img src="./1502172335245.png" alt="Alt text"><br><br>&gt;大家看了上面这个图片之后估计头都要晕了吧，这么多js都整在一行，让人怎么看呀，不用担心，按下图操作即可（也就是点击中间面板左下方的Pretty print就行了）<br>&gt;<img src="./1502172365940.png" alt="Alt text"><br>&gt;这时我们再回到Console面板时会惊奇的发现原来的链接后面的1现在变成91了（其实这里的数字1或者91就是代表votePost方法在源码中的行号 ）现在看出Pretty print按钮的强大之处了吧<br>知道了怎么样查看某一个按钮的源码，那接下来的工作便是调试了，调试第一步需要做的便是设置断点，其实设置断点很简单，点击一下上图所示的92即可，这时你会发现92行号旁边会多了一个图标，这里解释一下为什么不在91处设置断点，你可以试下，事实上根本就没法在91处上设置断点，因为它是函数的定义处，所以没法在此设置断点。<br><img src="./1502172407251.png" alt="Alt text"><br><br>&gt;设置好了断点后，你就会在右边Breakpoints方框里看到刚刚设置的断点。<br>我们先来介绍一下用到的调试快捷键吧（事实上我们也可以不用下表所示的快捷键，直接点击上图所示右侧栏最上层的一排按钮来进行调试，具体用哪个按钮，把鼠标放到按钮上方一会就会显示它相应的提示）<br><img src="./1502172424500.png" alt="Alt text"><br><br>&gt;其中值得一提的是，当我们点击“推荐”按钮进行调试的时候会发现，不管我们是按的F10进行调试还是按F11进行逐步调试，都没法进行$.ajax函数内部，即使我们在函数内部设置了断点也没有办法进入，这里按F8才是真正起效果的，不信你试试。<br>当我们在调试的时候，右侧Scope Variables里面会显示当前作用域以及他的父级作用域，以及闭包。你不仅能在右侧 Scope Variables(变量作用域) 一栏处看到当前变量，而且还能把鼠标直接移到任意变量上，就可以查看该变量的值。<br>用图说话（哈哈）<br><img src="./1502172441322.png" alt="Alt text"><br><br><br>&gt;刚刚我们介绍的只是在html里面能够看得到它绑定了onclick事件，这样我们就找到它绑定的js函数，如果它是在jQuery页面加载完成函数里面绑定的，这时候我们怎么知道它绑定的是哪个js函数呢，如果我们不知道绑定的js函数就更加不用说调试进去了<br>下面介绍一下如何查看，还是以刚刚那个测试网页为例子吧，但是这次我们来看“提交评论”作说明吧，<br>右击“提交评论”–&gt;审核元素，我们可以清楚的看到在这个按钮上未绑定任何事件。在Console面板内输入如下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lookEvents</span> (<span class="params">elem</span>) &amp;#123;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">$</span>.<span class="title">data</span> ? <span class="title">$</span>.<span class="title">data</span>(<span class="params"> elem, <span class="string">"events"</span>, undefined, true </span>) : <span class="title">$</span>.<span class="title">_data</span>(<span class="params"> elem, <span class="string">"events"</span> </span>);</span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line">var event = lookEvents($("#btn_comment_submit")[0]); // 获取绑定的事件</span><br></pre></td></tr></table></figure><br><br>如下图所示：<br><img src="./1502172491156.png" alt="Alt text"><br><br>&gt;按照上述介绍的方法定位到具体的blog-common.js里面，找到postComment  然后一层层的找到具体的代码，再设置断点就好了。<br>最后介绍一下一个神器，很好用的debugger<br>如果你自己写的代码，你执行的时候想让它在某一处停下来，只要写上的debugger就好了，不信你试试！哈哈<br>回到顶部<br><font color="red"><strong>谷歌控制台Elements面板</strong></font><br>要想打开谷歌控制台，有两种方式<br>  1. ctrl+shift+i<br>  2. f12<br>大家知道Elements面板最大的功能就是操作属性和修改html。这里我再说一些大家可能不太熟悉的特性，<br>  ● 拖拽节点, 调整顺序<br>  ● 拖拽节点到编辑器<br>  ● ctrl + z 撤销修改<br>这些功能是我觉得最有意思的，你们可以试试哦。<br>下面来具体说说几个复杂点的功能<br>回到顶部<br>查看元素上绑定的事情<br>  ● 默认会列出 All Nodes, 这些包括代理绑定在该节点的父/祖父节点上的事件, 因为在在冒泡或捕获阶段会经过该节点<br>  ● Selected Node Only 只会列出当前节点上绑定的事件<br>  ● 每个事件会有对应的几个属性 handler, isAtribute, lineNumber, listenerBody, sourceName, type, useCapture<br><br>  ● handler是处理函数, 右键可以看到这个函数定义的位置, 一般 js 库绑定事件会包一层, 所以这里很难找到对应handler<br>  ● isAtribute 表明事件是否通过 html 属性(类似onClick)形式绑定的<br>  ● useCapture 是 addEventListener 的第三个参数, 说明事件是以 冒泡 还是 捕获 顺序执行<br><br><img src="./1502172555574.png" alt="Alt text"><br><br><br><font color="red"><em>*样式操作</em></font></divid="d1"></em></em></length;i++)类似这样的循环时的问题，因为javascript没有代码块级别的变量，所以这里的i的访问权限其实是所在的方法。有x的书上会建议程序员把这样的变量声明放到一处去，但是从直观性上说，在大部分情况下都不够合理。></font><br>可以通过 ctrl + z 取消<br><br><img src="./1502172624759.png" alt="Alt text"><br><br><br>&gt;总况<br>目前控制台方法和属性有：<br>[“$$”, “$x”, “dir”, “dirxml”, “keys”, “values”, “profile”, “profileEnd”, “monitorEvents”, “unmonitorEvents”, “inspect”, “copy”, “clear”, “getEventListeners”, “undebug”, “monitor”, “unmonitor”, “table”, “$0”, “$1”, “$2”, “$3”, “$4”, “$“]<br>下面我们来一一介绍一下各个方法主要的用途。<br>一般情况下我们用来输入信息的方法主要是用到如下四个<br><br>console.log<br><br>用于输出普通信息<br><br><br>console.info<br><br>用于输出提示性信息<br><br>console.error<br>用于输出错误信息<br><br>console.warn<br>用于输出警示信息<br><br>console.debug<br>用于输出调试信息<br>用图来说话<br><img src="./1502172696626.png" alt="Alt text"><br><br><br>console对象的上面5种方法，都可以使用printf风格的占位符。不过，占位符的种类比较少，只支持字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）四种。<br><br><img src="./1502172707979.png" alt="Alt text"><br><br>&gt;  console.log(“%d年%d月%d日”,2011,3,26);<br>　 console.log(“圆周率是%f”,3.1415926);<br><img src="./1502172724060.png" alt="Alt text"><br><br><br>&gt;%o占位符，可以用来查看一个对象内部情况<br>var dog = &#123;&#125;;<br>dog.name = “大毛”;<br>dog.color = “黄色”;<br>console.log(“%o”, dog);<br><br><img src="./1502172744794.png" alt="Alt text"><br><br><br>&gt;下面重点说一下console.log的一些技巧<br><font color="purple"><strong>1、改变输出文字的样式</strong></font>

<p><img src="./1502172762173.png" alt="Alt text"></p>
<blockquote>
<p>console.log(“%c3D Text”,” text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em”);</p>
<p>console.log(‘%cRainbow Text ‘, ‘background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;’);</p>
</blockquote>
<p>输出的结果如下图所示：</p>
<p><img src="./1502172786415.png" alt="Alt text"></p>
<font color="purple"><strong>2、利用控制台输出图片</strong></font>

<p><img src="./1502172864203.png" alt="Alt text"></p>
<font color="purple"><strong>2、指定输出文字的样式</strong></font>

<p><img src="./1502172887901.png" alt="Alt text"></p>
<p>console.dirxml<br>用来显示网页的某个节点（node）所包含的html/xml代码</p>
<font color="purple"><strong>3、console.dirxml</strong></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;table id=&quot;mytable&quot;&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;A&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;A&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;A&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;bbb&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;aaa&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;ccc&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;111&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;333&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;222&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function () &amp;#123;</span><br><span class="line">        var mytable = document.getElementById(&apos;mytable&apos;);</span><br><span class="line">        console.dirxml(mytable);</span><br><span class="line">    &amp;#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br><br><img src="./1502172957318.png" alt="Alt text"><br><br><font color="purple"><strong>4、console.group和console.groupEnd</strong></font>

<blockquote>
<p>输出一组信息的开头和输出结束一组输出信息<br>看你需求选择不同的输出方法来使用，如果上述四个方法再配合group和groupEnd方法来一起使用就可以输入各种各样的不同形式的输出信息。</p>
</blockquote>
<p><img src="./1502173012717.png" alt="Alt text"></p>
<font color="purple"><strong>4、console.assert</strong></font>

<p>对输入的表达式进行断言，只有表达式为false时，才输出相应的信息到控制台</p>
<p><img src="./1502173055839.png" alt="Alt text"></p>
<font color="purple"><strong>5、console.count</strong></font>

<blockquote>
<p>（这个方法非常实用哦）当你想统计代码被执行的次数<br><img src="./1502173150296.png" alt="Alt text"></p>
</blockquote>
<font color="purple"><strong>6、console.dir</strong></font><br>&gt;(这个方法是我经常使用的 可不知道比for in方便了多少) 直接将该DOM结点以DOM树的结构进行输出，可以详细查对象的方法发展等等<br><br><br><img src="./1502173186549.png" alt="Alt text"><br><br><br><font color="purple"><strong>7、console.time和console.timeEnd</strong></font>

<blockquote>
<p>计时开始和计时结束（看了下面的图你瞬间就感受到它的厉害了）<br><img src="./1502173232556.png" alt="Alt text"></p>
</blockquote>
<font color="purple"><strong>8、console.profile和console.profileEnd</strong></font>

<blockquote>
<p>配合一起使用来查看CPU使用相关信息</p>
</blockquote>
<p><img src="./1502173278002.png" alt="Alt text"></p>
<blockquote>
<p>在Profiles面板里面查看就可以看到cpu相关使用信息<br><img src="./1502173301042.png" alt="Alt text"></p>
</blockquote>
<font color="purple"><strong>9、console.timeLine和console.timeLineEnd</strong></font>

<blockquote>
<p>配合一起记录一段时间轴</p>
</blockquote>
<font color="purple"><strong>10、console.trace</strong></font>

<blockquote>
<p>堆栈跟踪相关的调试<br>如果想查看具体API，可以上官方看看，具体地址为：<a href="https://developer.chrome.com/devtools/docs/console-api" target="_blank" rel="noopener">https://developer.chrome.com/devtools/docs/console-api</a><br>下面介绍一下控制台的一些快捷键</p>
</blockquote>
<font color="purple"><strong>11、方向键盘的上下键</strong></font><br>&gt;大家一用就知晓。比如用上键就相当于使用上次在控制台的输入符号<br><br><br><font color="purple"><strong>12、$_</strong></font>

<blockquote>
<p>命令返回最近一次表达式执行的结果，功能跟按向上的方向键再回车是一样的</p>
</blockquote>
<p><img src="./1502173448680.png" alt="Alt text"></p>
<p>上面的\$_需要领悟其奥义才能使用得当，而\$0~$4则代表了最近5个你选择过的DOM节点。<br>什么意思？在页面右击选择审查元素，然后在弹出来的DOM结点树上面随便点选，这些被点过的节点会被记录下来，而\$0会返回最近一次点选的DOM结点，以此类推，$1返回的是上上次点选的DOM节点，最多保存了5个，如果不够5个，则返回undefined。</p>
<blockquote>
<p>\$ // 简单理解就是 document.querySelector 而已。<br>$$ // 简单理解就是 document.querySelectorAll 而已。<br>$_ // 是上一个表达式的值<br>$0-$4 // 是最近5个Elements面板选中的DOM元素，待会会讲。<br>dir // 其实就是 console.dir<br>keys // 取对象的键名, 返回键名组成的数组<br>values // 去对象的值, 返回值组成的数组<br>看一下chrome控制台一个简单的操作，如何查看页面元素，看下图就知道了</p>
</blockquote>
<p><img src="./1502173745894.png" alt="Alt text"></p>
<font color="purple"><strong>13、Chrome 控制台中原生支持类jQuery的选择器</strong></font>

<blockquote>
<p>也就是说你可以用$加上熟悉的css选择器来选择DOM节点</p>
</blockquote>
<p><img src="./1502173787555.png" alt="Alt text"></p>
<font color="purple"><strong>14、copy</strong></font><br>&gt;通过此命令可以将在控制台获取到的内容复制到剪贴板(如果在elements面板中选中某个节点，也可以直接按ctrl+c执行复制操作)<br><br><img src="./1502173822819.png" alt="Alt text"><br><br><font color="purple"><strong>15、keys和values</strong></font>

<blockquote>
<p>前者返回传入对象所有属性名组成的数据，后者返回所有属性值组成的数组<br><img src="./1502173861020.png" alt="Alt text"></p>
</blockquote>
<font color="purple"><strong>14、console.table</strong></font>

<p><img src="./1502173882070.png" alt="Alt text"></p>
<p><font color="purple"><strong>14、monitor &amp; unmonitor</strong></font></p>
<blockquote>
<p>monitor(function)，它接收一个函数名作为参数，比如function a,每次a被执行了，都会在控制台输出一条信息，里面包含了函数的名称a及执行时所传入的参数。<br>而unmonitor(function)便是用来停止这一监听。<br><img src="./1502173938698.png" alt="Alt text"><br>看了这张图，应该明白了，也就是说在monitor和unmonitor中间的代码，执行的时候会在控制台输出一条信息，里面包含了函数的名称a及执行时所传入的参数。当解除监视（也就是执行unmonitor时）就不再在控制台输出信息了。</p>
</blockquote>
<h4 id="关于定时器清除"><a href="#关于定时器清除" class="headerlink" title="关于定时器清除"></a>关于定时器清除</h4><blockquote>
<p>许多人在清除的定时器的时候会把存储定时器个数的变量赋值为null<br>看代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let timer=setInterval(()=&gt;&amp;#123;&amp;#125;,1000);</span><br><span class="line">clearInterval(timer);</span><br><span class="line">timer=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>这样做有什么好处呢？<br>其实当我们执行clearInterval的时候 的确把定时器清掉了，如果我们在函数作用域中这样做那么浏览器会自动进行垃圾回收<br>但是如果timer是在全局下声明的，那么这时候短时间是不会被回收的，这时候我们手动把它设置为null ，会便于浏览器的垃圾回收。</p>
</blockquote>
</font>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/03/胡子课堂react小记/" rel="next" title="胡子课堂react小记">
                <i class="fa fa-chevron-left"></i> 胡子课堂react小记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/03/vue笔记/" rel="prev" title="vue笔记">
                vue笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="daima Hao" />
            
              <p class="site-author-name" itemprop="name">daima Hao</p>
              <p class="site-description motion-element" itemprop="description">you can do everything with javascript!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#关于定时器清除"><span class="nav-number">1.</span> <span class="nav-text">关于定时器清除</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">daima Hao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
