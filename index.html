<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="you can do everything with javascript!">
<meta property="og:type" content="website">
<meta property="og:title" content="好带马的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="好带马的个人博客">
<meta property="og:description" content="you can do everything with javascript!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="好带马的个人博客">
<meta name="twitter:description" content="you can do everything with javascript!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>好带马的个人博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7f7fc0818bf01cde8c4db632bad33df3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">好带马的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/vue笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daima Hao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="好带马的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/vue笔记/" itemprop="url">vue笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T17:07:48+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Vue-js简介"><a href="#Vue-js简介" class="headerlink" title="Vue.js简介"></a>Vue.js简介</h4><blockquote>
<p>Vue是一套用于构建用户界面的渐进式框架，与其他框架不同，Vue采用自底向上的增量开发设计，Vue的核心库只关心视图层。</p>
</blockquote>
<p>———————————————————————————————————————————————————————–我是分割线</p>
<h4 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h4><blockquote>
<p>Vue的核心是一个允许采用简洁的模版语法来声明式的将数据渲染进DOM的系统，渲染完成后，数据和DOM便绑定在一起，数据如果改变DOM就会更新。</p>
</blockquote>
<p>———————————————————————————————————————————————————————–我是分割线</p>
<h4 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h4><blockquote>
<ol>
<li>在Vue中v-开头的表示Vue提供的指令属性，它可以在渲染的DOM上应用特殊的响应式的行为。例如：v-if判断条件，v-for循环，v-bind绑定，v-on事件监听，v-model实现表单输入和数据的双向绑定….</li>
</ol>
</blockquote>
<p>———————————————————————————————————————————————————————–我是分割线</p>
<h4 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h4><blockquote>
<ol>
<li>使用v-model将表单元素的输入和数据双向绑定</li>
</ol>
</blockquote>
<p>———————————————————————————————————————————————————————–我是分割线</p>
<h4 id="组件化应用构建"><a href="#组件化应用构建" class="headerlink" title="组件化应用构建"></a>组件化应用构建</h4><blockquote>
<ol>
<li>组件系统是Vue的另一个重要概念，我们可以发现几乎任意类型的项目都可以抽象为一个组件，在Vue中一个组件本质上是一个拥有预定义选项的一个Vue实例，在Vue中注册组件很简单</li>
</ol>
</blockquote>
<p><code>Vue.component(&#39;todo-item&#39;, &amp;#123;
    props:参数
  template: &#39;&lt;li&gt;这是个待办项&lt;/li&gt;&#39;
&amp;#125;)</code></p>
<p>———————————————————————————————————————————————————————–我是分割线</p>
<h4 id="与自定义元素的关系"><a href="#与自定义元素的关系" class="headerlink" title="与自定义元素的关系"></a>与自定义元素的关系</h4><blockquote>
<ol>
<li>我们可以发现Vue的组件非常类似于自定义元素，它是Web组件规范的一部分，但是还是有关键差别：<ul>
<li>Web 组件规范仍然处于草案阶段，并且尚无浏览器原生实现。相比之下，Vue 组件不需要任何补丁，并且在所有支持的浏览器 (IE9 及更高版本) 之下表现一致。必要时，Vue 组件也可以包装于原生自定义元素之内。</li>
<li><ul>
<li>Vue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流，自定义事件通信以及构建工具集成。</li>
</ul>
</li>
</ul>
</li>
</ol>
</blockquote>
<p>———————————————————————————————————————————————————————–我是分割线</p>
<h4 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h4><blockquote>
<ol>
<li>每一个Vue应用都是通过Vue函数创建一个Vue实例开始的，当创建一个Vue实例的时候可以传入一个选项对象，一个Vue应用由一个通过new Vue创建的根Vue 实例以及可选的嵌套的，可复用的组件树组成。</li>
</ol>
</blockquote>
<p>———————————————————————————————————————————————————————–我是分割线</p>
<h4 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h4><blockquote>
<ol>
<li>当一个Vue实例被创建的时候，它向Vue的响应式系统加入了其data对象中能找到的所有属性，当这些属性的值发生改变的时候，师徒将会产生响应，即匹配更新为新的值。</li>
</ol>
</blockquote>
<p><code>var data=&amp;#123;a:1&amp;#125;;
var vm=new Vue(&amp;#123;
    data:data
&amp;#125;);
// Vue中的data和传入的data对象引用的是同一个对象。
vm.a===data.a
//设置属性也会影响到原始的数据
vm.a=2;
data.a //=&gt;2
//相反也一样
data.a=3;
vm.a //3</code></p>
<ol>
<li>当数据改变的时候，视图就会重新渲染，值得注意的是，只有当实例创建的时候data中存在的属性才是响应式的，如果在实例上后来添加的属性是不能够响应的触发视图更新的，所以我们如果需要一个值在某些时候，那么我们可以先把他置为空，以便以后使用，除了data属性，Vue实例还暴露了一些有用的属性和方法，它们都带有前缀$便于区分<br><code>var data=&amp;#123;a:1&amp;#125;; var vm=new Vue(&amp;#123;
el:&#39;#example&#39;,data:data
&amp;#125;)
vm.$data===data//=&gt;true;
vm.$el===document.getElementById(&#39;example&#39;);//=&gt;true；
vm.$watch(&#39;a&#39;，function(newValue,oldValue)&amp;#123;&amp;#125;);
//这个回调将在a的值变化后调用</code></li>
</ol>
<p>———————————————————————————————————————————————————————–我是分割线</p>
<h4 id="实例的生命周期"><a href="#实例的生命周期" class="headerlink" title="实例的生命周期"></a>实例的生命周期</h4><blockquote>
<ol>
<li>每个Vue实例在被创建之前要经过一系列的初始化过程，例如设置数据监听，编译模版，挂载实例到DOM，在数据变化后更新DOM，在这个过程中也会运行很多生命周期钩子的函数，可以让我们在一些特定的场景下添加自己的代码。</li>
<li><p>Vue生命周期钩子函数有：</p>
<ul>
<li>created钩子函数会在实例创建之后执行。</li>
<li>mounted钩子函数会在实例挂载到DOM后执行。</li>
<li>updated钩子函数将会在组件更新后执行</li>
<li>destroyed钩子函数将会在组件销毁之后执行</li>
</ul>
</li>
<li><p>需要注意的是<font color="red">不要在选项属性或者回调上是有箭头函数，比如<code>created:()=&gt;&amp;#123;console.log(this.a)&amp;#125;</code>或vm.$watch(‘a’,newValue=&gt;&#123;this.,myMethod()&#125;),因为箭头箭头函数是和父级上下文绑定在一起的，this不会是如你所预期的Vue实例，经常导致Uncaught TypeError: Cannot read property of undefined或Uncaught TypeError: this.myMethod is not a function 之类的错误。</font></p>
</li>
<li><p>生命周期图示<br><img src="https://cn.vuejs.org/images/lifecycle.png" alt=""><br>步骤解释：</p>
<ul>
<li>new Vue获得Vue的一个实例</li>
<li>init Events&amp;&amp;Lifecycle 初始化实例的事件和生命周期函数</li>
<li>beforeCreate 生命周期钩子函数  在实例被创建之前调用</li>
<li>init injections&amp;&amp;reactivity，初始化注入数据和响应式系统。</li>
<li>created 生命周期钩子函数 在实例被创建完成后调用</li>
<li>判断可选项对象中是否有el这个属性，如果没有当vm.$mount(el)被调用的时候就会进入下一个判断，如果有直接进入下一个判断</li>
<li>判断是否有template这个属性，如果有就编译这个模版到render函数，如果没有就像编译template一样把该元素的outerHTML属性编译到render函数</li>
<li>beforeMount 生命周期钩子函数，在组件挂载之前调用。</li>
<li>创建 vm.$el(即得到真实的DOM)然后用真实的DOM替换掉el元素。</li>
<li>mounted 生命周期钩子函数，组件挂载完成时调用</li>
<li>Mounted（<font color="red">这个可能是历史原因</font>））（当数据改变的时候，先调用生命周期钩子函数beforeUpdate在组件更新重新渲染前调用，虚拟DOM重新渲染和patch，然后调用组件更新完成的生命周期函数updated）</li>
<li>当vm.$destroy()被调用的时候，先调用组件销毁前的钩子函数beforeDestroy</li>
<li>卸载观察者函数，子组件和事件监听函数</li>
<li>组件销毁阶段</li>
<li>调用组件生命周期钩子函数destroyed(这个也可能是历史原因没有修改掉)。</li>
</ul>
</li>
</ol>
</blockquote>
<p>———————————————————————————————————————————————————————–我是分割线</p>
<h4 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h4><blockquote>
<ol>
<li>Vue使用了基于HTML的模版语法，允许开发者声明式的将DOM绑定至底层Vue实例的数据。所有Vue的模版都是合法的html，所以能被遵循规范的浏览器和HTML解析器解析。在底层实现上，Vue将模版编译成虚拟DOM渲染函数，结合响应系统，在应用状态改变时，Vue能够只能地计算出重新渲染组件的最小代价并应用到DOM操作上，如果你熟悉DOM并且偏爱js的原始力量，那么你可以直接写渲染函数，使用可选的JSX语法</li>
<li>插值：<ul>
<li>文本 数据绑定最常见的形式就是使用”Mustache”（大胡子语法）语法，Mustache会替代对应数据对象上的属性的值，需要记住无论何时，只要数据对象上对应的属性值发生改变，那么插值处的内容就会跟随更新，我们可以使用v-once指令来让它只执行依次插值。</li>
<li>原始HTML 大胡子语法会让数据解释为普通文本，而非HTML代码，为了输出真正的HTML，你需要v-html指令（和react的dangerouslySetHTML相似），使用v-html指令后，这个元素会直接作为HTML，而会忽略解析属性中的数据绑定，需要注意的是你不能使用v-html来复合局部模版，因为Vue不是基于字符串的模版引擎，反之，对于用户界面（UI），组件更适合作为可重用和可组合的基本单位。</li>
<li><font color="red">在站点上动态渲染HTML会非常危险，v-html只是用于对可信内容的HTMTL的插值，绝对不要对用户提供的内容使用插值</font></li>
</ul>
</li>
<li>特性 因为大胡子语法不能作用域HTML特性上，遇到这种情况我们应该使用v-bind，由于布尔特性的情况，所以v-bind的值存在就暗示这true，如果v-bind绑定的值是null、undefined或false那么绑定的te性甚至不会包含在渲染出来的元素中</li>
<li>使用javascript表达式 对于所有的数据绑定vue都提供了完全的js表达式支持，这些表达式会在所属实例的数据作用下作为js被解析，但是需要特别注意的是，每个绑定都只能半酣单个表达式，所以下面的例子是错的<br><code>//这是语句，不要表达式
&amp;#123;var a=1&amp;#125;;
//流控制不会生效请使用三元表达式
&amp;#123;&amp;#123;if(ok)&amp;#123;return message&amp;#125;&amp;#125;&amp;#125;</code><br>模版表达式都放在沙盒中，只能访问全局标量的一个白名单，例如Math和Date。不应该在模版表达式中视图访问用户定义的全局变量。</li>
<li><p>指令 指令指的是所有带有v-前缀的特殊属性，指令属性的值预期是单个javascript表达式，v-for是例外情况；指令的职责是当表达式的值改变的时候，将其产生整个javascript的连带影响，响应式的作用于DOM</p>
</li>
<li><p>修饰符 修饰符是以半角句号.指明的特殊后缀。用于指定一个指令应该以特殊的方式绑定，例如<br><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;</code></p>
</li>
<li><p>缩写  v- 前缀作为一种视觉提示，用来识别模板中 Vue 特定的特性。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，v- 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue.js 管理所有模板的单页面应用程序 (SPA - single page application) 时，v- 前缀也变得没那么重要了。因此，Vue.js 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写：</p>
<ul>
<li>v-bind <code>&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;</code> 缩写为 <code>&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;</code></li>
<li>v-on <code>&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</code> 缩写后<code>&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</code></li>
<li>虽然缩写语法看起来和HTML不同，但是’:’和’@’确实特性名中允许的的合法字符，在所有支持Vue的浏览器中都能被解析，而且他们不会出现在最终的标记中，缩写语法是可选的。</li>
</ul>
</li>
</ol>
</blockquote>
<p>———————————————————————————————————————————————————————–我是分割线</p>
<h4 id="计算属性和观察者"><a href="#计算属性和观察者" class="headerlink" title="计算属性和观察者"></a>计算属性和观察者</h4><p>#####计算属性</p>
<blockquote>
<ol>
<li>计算属性 大胡子语法设计的初衷是负责简单的运算，所以任何复杂的逻辑运算我们都应该交给计算属性，计算属性其实就是在可选项对象的添加一个computed对象，里面的键就是需要计算的属性，值对应的函数就会被当作计算属性的getter函数；</li>
<li>计算属性的缓存和方法，当我们想｛｛｝｝加入一个同样作用的函数时，你会发现结果是相同的，不同的计算属性会依赖于他们进行缓存，这意味只有在相关依赖发生改变时，计算属性才会重新求值，否则就返回之前的计算结果。<br>这同样以为着下面的属性将不再更新<code>computed:&amp;#123;now: function()&amp;#123;return Data.now()&amp;#125;&amp;#125;</code>，因为Date.now没有响应式依赖。</li>
<li>相比之下每当触发重新渲染时，调用方法总会再次执行函数，缓存机制可以磅值我们在性能开销比较大的计算属性中保持性能避免不必要的计算，如果你不希望有缓存请使用方法来计算。</li>
<li>计算属性和侦听属性 Vue提供了一种更通用的方式来观察和响应Vue实例上的数据变动，但是你很容易滥用watch，特别是当你要侦听的数据随其他数据变动而变动时，这个时候当你的一些数据依赖其他数据的时候，你更适合使用computed计算属性。<br><code>var vm = new Vue(&amp;#123;
el: &#39;#demo&#39;,
data: &amp;#123;
 firstName: &#39;Foo&#39;,
 lastName: &#39;Bar&#39;,
 fullName: &#39;Foo Bar&#39;
&amp;#125;,
watch: &amp;#123;
 firstName: function (val) &amp;#123;
   this.fullName = val + &#39; &#39; + this.lastName
 &amp;#125;,
 lastName: function (val) &amp;#123;
   this.fullName = this.firstName + &#39; &#39; + val
 &amp;#125;
&amp;#125;
&amp;#125;);</code><br><code>var vm = new Vue(&amp;#123;
el: &#39;#demo&#39;,
data: &amp;#123;
 firstName: &#39;Foo&#39;,
 lastName: &#39;Bar&#39;
&amp;#125;,
computed: &amp;#123;
 fullName: function () &amp;#123;
   return this.firstName + &#39; &#39; + this.lastName
 &amp;#125;
&amp;#125;
&amp;#125;)</code><br>当this.firstName或this.lastName改变的时候就会重新计算，而如果使用watch则需要监控两个属性。</li>
<li>计算属性的set 计算属性默认只有getter，不过在需要的时候你也可以提供一个setter，如果我们设置了set那么我们就可以对计算属性进行赋值，并且相应的setter如果被调用，get也会被重新计算</li>
<li>侦听器 虽然计算属性在大多数情况下更合适，但是我们有时也需要一个自定义的侦听器，Vue提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时，执行异步或开销较大的操作时这个方式是最有用的<br>watch和computed的区别在于 wactch善于处理一个数据被多个数据依赖的场景，而computed则适合处理一个数据依赖多个数据的场景</li>
</ol>
</blockquote>
<p>———————————————————————————————————————————————————————–我是分割线</p>
<h4 id="Class与Style绑定"><a href="#Class与Style绑定" class="headerlink" title="Class与Style绑定"></a>Class与Style绑定</h4><blockquote>
<ol>
<li>对象语法  &#123;键：值&#125;可以动态切换class <code>&lt;div v-bind:class=&quot;&amp;#123; active: isActive &amp;#125;&quot;&gt;&lt;/div&gt;</code>，是否添加键对应的class取决于值的Boolean结果。当v-bind：class同样可以与普通的class共存，会同时被添加到类名中。绑定的数据对象不必须定义在模版里，也可以放到Data中，</li>
<li>数组语法 我们可以把一个数组传给v-bind，来应用一个class列表<code>&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;；data: &amp;#123;
activeClass: &#39;active&#39;,
errorClass: &#39;text-danger&#39;
&amp;#125;</code>,也可以使用三元表达式<code>&lt;div v-bind:class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;</code>，当有多个条件class时，数组同样支持对象语法，<code>&lt;div v-bind:class=&quot;[&amp;#123;active:isActive,errorClass&amp;#125;]&quot;&gt;&lt;/&gt;</code></li>
<li>用在组件上 当在一个自定义组件上使用class属性时，它会被绑定到组件的根元素上，并且这个元素上已经存在的类名不会被覆盖，添加到后面，这对数据绑定的class同样使用。</li>
</ol>
</blockquote>
<p>#####绑定内联样式</p>
<blockquote>
<ol>
<li>对象语法 使用v-bind:style方式很像css，但是它是一个js对象，属性名可以用驼峰命名或短横线分隔，或者直接在data里面声明这个样式对象更好，使得模版更清晰，同样的对象语法也常常结合对象的计算属性使用</li>
<li>数组语法 数组语法可以将多个样式对象应用到同一个元素上。<code>&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</code></li>
<li>自动添加前缀，当v-bind：style使用需要添加浏览器引擎前缀的css属性时，Vue会自动检测并添加</li>
<li>多种值，从2.3.0 版本开始你可以为style绑定中的属性提供一个包含多个值的数组，常用语提供多个带前缀的值，例如：<code>&lt;div :style=&quot;&amp;#123; display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] &amp;#125;&quot;&gt;&lt;/div&gt;</code>，不过这样的书写方式只有数组的最后一个被浏览器支持的值被渲染。</li>
</ol>
</blockquote>
<p>———————————————————————————————————————————————————————–我是分割线</p>
<h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><blockquote>
<ol>
<li>v-if 实现条件渲染。v-if是一个指令必须添加到一个元素上，但是如果想要切换多个元素呢？我们这时可以用一个无意义的包裹元<template>包裹他们，最终的渲染结果不包含<template>,v-else 相当于if的else，2.1.0 版本新增 v-else-if 相当于else-if</template></template></li>
<li>用key实现管理可复用元素，由于Vue会尽可能高效的渲染元素，通常会复用已有元素而不是重新渲染，例如你用v-if判断两个输入框的显示，Vue会引用同一个的元素只是改变他们需要改变的值，但是这种情况也并非都满足需求，如果你不想这种复用发生，你可以为两个元素添加一个唯一key属性表明他们是独立的，这样Vue在你操作就会重新渲染而不是复用，注意input的label元素仍会被复用因为它没有添加key属性</li>
<li>v-show 也是一个根据条件渲染的属性，不同的是v-show的元素始终都在DOM中并被渲染，简单的说Vue只是控制了它的display属性，另外值得注意的是，v-show并不支持<template>元素也不支持v-else</template></li>
<li>v-if和v-show比较：<ul>
<li>v-if是比较纯粹的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当的被销毁和重建，但是它也是惰性，如果条件不成立那么它什么都不会做，</li>
<li>v-show是不管初始条件是什么，都会渲染只是通过css属性来控制它的显示和隐藏。</li>
<li>一般来说v-if有更高的切换开销（因为它可能涉及到多次销毁和重建），而v-show则有更高的初次渲染开销，因为无论什么条件他都会渲染，所以我们需要非常频繁的切换，那么v-show较好，如果我们切换很少那么显然v-if更适合。</li>
</ul>
</li>
<li>当v-if与v-for一起使用时，v-for具有比v-if更高的优先级。</li>
</ol>
</blockquote>
<p>———————————————————————————————————————————————————————–我是分割线</p>
<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><blockquote>
<ol>
<li>v-for会根据一组数组的选项列表进行渲染，v-for指令需要使用item in items形式的特殊愈发，items是源数据数据，item是迭代的每一项。在v-for中我们拥有对父作用域完全的访问权限，还支持一个可选的参数，index，标识迭代的索引，你可以用of或者in作为分隔符，因为他们是最接近于js迭代器的语法。</li>
<li>对象的v-for，当我们使用v-for对对象迭代时它可以接受一个必选参数value，两个可选参数index，key，分别表示值，键，序号，需要注意的是Vue对对象的遍历使用的是Object。.keys（）,所以并不能保证在所有的js引擎下都可以实现。</li>
<li>key 当Vue使用v-for正在更新渲染过的列表元素时，它会默认采用“就地复用的”策略，如果数据项顺序改变，Vue将不会移动DOM元素来匹配数据项的数学怒，而是简单的复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素，这个类似于vue1.x的tack-by=“$index”,虽然这个模式默认是高效的，但是只适用于不依赖组件状态或临时DOM状态（例如：表单输入值）的列表渲染输出，所以为了给Vueyi一个提示便于追踪，从而重新排序元素，你需要为每一项提供一个唯一的key属性，因为它是一个属性所以你需要用v-bind来动态绑定，建议尽可能在使用v-for时候提供key，除非你是故意而为。</li>
</ol>
</blockquote>
<p>#####数组更新检测</p>
<blockquote>
<ol>
<li>变异方法  Vue包含一组观察数组的变异方法，它们也会触发视图更新，有（push、pop、shift、unshift、splice、sort、reverse）</li>
<li><p>替换数组 变异方法的意思就是会改变原数组，非变异方法，总是返回一个新数组例如（filter，concat，slice），当你用返回的新数组去替换旧的数组，Vue并不用重新渲染整个列表所以你不必过多担心性能问题。<br>3.数组 注意事项</p>
<ul>
<li>基于js本身的限制，Vue不能检测以下变动的数据，利用索引直接设置的值和修改数组长度。</li>
<li>对于以上两种可以使用别的方法替代来触发状态更新，Vue.set(example1.items,indexOfItem,newValue)和使用slice重新复制一个童谣长度的新数组）。</li>
</ul>
</li>
<li><p>对象更改检测注意事项。</p>
<ul>
<li>同样由于js的限制，Vue不能检测对象属性的添加和删除。</li>
<li>对于已经创建的实例，可以使用Vue.set（vm.$set）像嵌套对象中添加响应式属性，注意是嵌套对象，根级别的对象是不行的，当你需要向已有对象赋予多个新属性时，你不应该是有原有对象，应该重新创建一个新的对象然后把其余的属性值浅拷贝进去，这样才能实现响应式属性</li>
</ul>
</li>
</ol>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/js杂谈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daima Hao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="好带马的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/js杂谈/" itemprop="url">js杂谈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T17:06:30+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>####<strong>随便记点</strong></p>
<p>=====================================================================================</p>
<p>####<strong>PS:prototype、<strong>proto</strong>、原型和原型链</strong></p>
<blockquote>
<p>在JS中，万物皆对象，对象因为你的“关注”而产生。每个对象都有自己的属性特征和行为方法，函数、数组、对象等都可以被视为对象，那么js中的对象又是怎么产生的呢？</p>
<p>其他大型语言里，对象都和“类”这个概念紧密相连，“类”是对象的一个抽象概念，每个对象都是通过个“类”的构造方法创建的。而js中抛弃了“类”的概念，引入另外一个抽象概念——“原型”。js中每个对象都有一个原型，原型也是对象，所以原型也有自己的原型对象，如果一路找上去，最终会找到Object。也就是说js中所有对象都是由Object克隆出来的，Object是所有对象的起始。</p>
<p>创建对象的方法</p>
<p>1.构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let Construct=function(name,age)&amp;#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.age=age;</span><br><span class="line">&amp;#125;;</span><br><span class="line">let c1=new Construct(&quot;123&quot;,123);</span><br></pre></td></tr></table></figure></p>
<p>通过函数Construct，来创建一个实例对象c1，函数Construct也可称为构造函数。构造函数就是普通函数，只不过通过这个函数new了一个实例对象。在new的过程中通过构造函数的函数体，给对象c1增加了属性。</p>
</blockquote>
<p>2.构造函数加原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Construct=<span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)&amp;#123;</span></span><br><span class="line"><span class="function">    <span class="title">this</span>.<span class="title">name</span>=<span class="title">name</span>;</span></span><br><span class="line"><span class="function">    <span class="title">this</span>.<span class="title">age</span>=<span class="title">age</span>;</span></span><br><span class="line"><span class="function">&amp;#125;;</span></span><br><span class="line"><span class="function"><span class="title">Construct</span>.<span class="title">prototype</span>.<span class="title">fn</span>=<span class="title">function</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">log</span>(<span class="params"><span class="string">"hello world"</span></span>);</span></span><br><span class="line"><span class="function">&amp;#125;;</span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">c1</span>=<span class="title">new</span> <span class="title">Construct</span>(<span class="params"><span class="string">"123"</span>,<span class="number">123</span></span>);</span></span><br><span class="line"><span class="function"><span class="title">c1</span>.<span class="title">fn</span>(<span class="params"></span>);</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在构造函数的基础上，给构造函数的原型（Constructor.prototype）加一个方法fn，将该方法从构造函数的原型（Constructor.prototype）复制到新实例对象c1的原型（c1.prototype ）上。很多人会认为这两个是一个东西，我不这么认为，我理解为每一个对象都有一个自己的原型，下文会详细解释。这样构造函数原型中的方法就会被复制到c1的原型上，c1在自身中找不到fn这个方法，就会去自己的原型:c1. prototype 上去找。</p>
</blockquote>
<p>3.JSON<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let c1=&amp;#123;</span><br><span class="line">    <span class="string">"name"</span>:<span class="string">"123"</span>,</span><br><span class="line">    <span class="string">"age"</span>:<span class="number">123</span>,</span><br><span class="line">    <span class="string">"fn"</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">console</span>.<span class="title">log</span>(<span class="params"><span class="string">"hello world"</span></span>);</span></span><br><span class="line"><span class="function">    &amp;#125;,</span></span><br><span class="line"><span class="function">&amp;#125;;</span></span><br><span class="line"><span class="function"><span class="title">c1</span>.<span class="title">fn</span>(<span class="params"></span>);</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>JSON是js创建对象的一个简便算法，但也有它的缺点，在需要创建的对象数量很多时就不适用。构造函数创建的c1也有一个原型，这个原型为空，可以通过. prototype 给它的原型添加属性和方法。</p>
</blockquote>
<p>4.class</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Construct</span>&amp;#123</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&amp;#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.age=age;</span><br><span class="line">    &amp;#125;</span><br><span class="line">    fn()&amp;#123;</span><br><span class="line">        console.log("hello world");</span><br><span class="line">    &amp;#125;</span><br><span class="line">&amp;#125;</span><br><span class="line">let c1=new Construct();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先创建一个Construct的类，在通过new创建一个新的实例对象c1。在Construct这个类中，有一个名为constructor的函数，它可以把里面的属性通过new的过程初始化给c1；还有一个名为fn的方法，这个方法被直接添加到Construct的原型（Construct.prototype）上，在new的过程中又被复制到了c1的原型（c1. prototype ）上，所以c1本身没有这个方法，却可以通过原型链调用这个方法。</p>
<p>js的class是es6新增的一个概念，class的提出让我们在创建对象时的逻辑和操作更偏向于面向对象的语言。但它不是一个“真类”，是用函数模拟出来的一个“类”，底层和java等语言还是有很大的差别。</p>
<p>原型链</p>
<p>对象可以通过 . proto 这个方法找到该对象的原型，有一个特殊的对象——函数，函数通过.prototype找到该函数的原型对象，.prototype这个方法只有函数才可以调用，而找到的是原型对象，所以不能继续用.prototype这个方法。而. proto 这个方法可以重复调用，通过. proto . proto 来找到最顶层的原型对象Object，这条线就称为原型链。</p>
<p>不管是函数的原型还是实例对象的原型. proto 后都找到Object，也就是&#123;&#125;</p>
<p>原型对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Construct=<span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)&amp;#123;</span></span><br><span class="line"><span class="function">    <span class="title">this</span>.<span class="title">name</span>=<span class="title">name</span>;</span></span><br><span class="line"><span class="function">    <span class="title">this</span>.<span class="title">age</span>=<span class="title">age</span>;</span></span><br><span class="line"><span class="function">&amp;#125;;</span></span><br><span class="line"><span class="function"><span class="title">Construct</span>.<span class="title">prototype</span>.<span class="title">fn</span>=<span class="title">function</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">log</span>(<span class="params"><span class="string">"hello world"</span></span>);</span></span><br><span class="line"><span class="function">&amp;#125;;</span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">c1</span>=<span class="title">new</span> <span class="title">Construct</span>(<span class="params"><span class="string">"123"</span>,<span class="number">123</span></span>);</span></span><br></pre></td></tr></table></figure></p>
<p>Construct这个构造函数（也可视为对象）在我们声明的时候，就已经产生了一个原型对象<br>（Construct.prototype），通过原型对象添加的方法给上面加入方法fn，然后我们通过Construct，new一个新对象c1，要理解原型对象，首先我们要理解new的这个过程，new的过程一共分为3步：</p>
<p>先通过构造函数Construct来新建一个实例c1，并新建一个c1的原型对象：c1.prototype （此时，c1和c1. prototype 都是空的）。<br>c1. prototype = Construct.prototype（把Construct.prototype上的方法fn赋到c1.prototype 上，此时c1还是空的，c1. prototype 上有了一个方法fn）<br>通过函数Construct的函数体，对c1进行初始化设置，将属性和属性值赋给c1。<br>到此三步结束，c1中具有了属性和属性值，c1的原型（c1. prototype ）上有了fn这个方法，函数Construct的原型（Construct.prototype）没有改变，并且每次new对象的时候，都会重复上述的三个动作。可以通过分别查看c1、 c1. prototype 、Construct.prototype来验证刚才的证明。</p>
<p>并且我们在使用原型添加方法的时候，如果通过c1. prototype 来添加的属性和方法，并不会影响Construct.prototype里的内容，也不会影响其他新new出来的实例对象，只会改变c1自己的原型。而通过Construct.prototype去修改的原型，会影响其他新new出来的实例对象，这更好地解释了刚才的想法。</p>
</blockquote>
<p><img src="./1502247834723.png" alt="Alt text"></p>
<p>=====================================================================================</p>
<p>####PS：sort排序原理：</p>
<blockquote>
<p>sort() 方法用于对数组的元素进行排序。<br>语法：arrayObject.sort(sortby)；参数sortby可选。规定排序顺序。必须是函数。<br>注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p>
<p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：<br>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。<br>若 a 等于 b，则返回 0。<br>若 a 大于 b，则返回一个大于 0 的值。</p>
</blockquote>
<p>例1：我们将创建一个数组，并按字母顺序进行排序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"James"</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"Adrew"</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"Martin"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr.sort())</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：</p>
<p>George,John,Thomas,James,Adrew,Martin<br>Adrew,George,James,John,Martin,Thomas</p>
</blockquote>
<p>例2：我们将创建一个数组，并按字母顺序进行排序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"10"</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"5"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"40"</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"25"</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"1000"</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr.sort())</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出：</p>
<p>10,5,40,25,1000,1<br>1,10,1000,25,40,5<br>请注意，上面的代码没有按照数值的大小对数字进行排序，要实现这一点，就必须使用一个排序函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumber</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function">&amp;#123;</span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="title">a</span> - <span class="title">b</span></span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">arr</span> = <span class="title">new</span> <span class="title">Array</span>(<span class="params"><span class="number">6</span></span>)</span></span><br><span class="line">arr[0] = "10"</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"5"</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"40"</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"25"</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"1000"</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr.sort(sortNumber))</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<p>10,5,40,25,1000,1<br>1,5,10,25,40,1000<br>当然如果想根据数组对象中的某个属性值进行排序呢？</p>
<p>sort方法接收一个函数作为参数，这里嵌套一层函数用来接收对象属性名，其他部分代码与正常使用sort方法相同。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">    &amp;#123;name:'zopp',age:0&amp;#125;,</span><br><span class="line">    &amp;#123;name:'gpp',age:18&amp;#125;,</span><br><span class="line">    &amp;#123;name:'yjj',age:8&amp;#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">property</span>)&amp;#123;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">function</span>(<span class="params">a,b</span>)&amp;#123;</span></span><br><span class="line">        var value1 = a[property];</span><br><span class="line">        <span class="keyword">var</span> value2 = b[property];</span><br><span class="line">        <span class="keyword">return</span> value1 - value2;</span><br><span class="line">    &amp;#125;</span><br><span class="line">&amp;#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(compare(<span class="string">'age'</span>)))</span><br></pre></td></tr></table></figure></p>
<p>结果如图所示：</p>
<p>如何根据参数不同，来确定是升序排列，还是降序排序呢？<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sortBy: <span class="function"><span class="keyword">function</span>(<span class="params">attr,rev</span>)&amp;#123;</span></span><br><span class="line"><span class="function">    //第二个参数没有传递 默认升序排列</span></span><br><span class="line"><span class="function">    <span class="title">if</span>(<span class="params">rev ==  undefined</span>)&amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">rev</span> = 1;</span></span><br><span class="line"><span class="function">    &amp;#125;<span class="title">else</span>&amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">rev</span> = (<span class="params">rev</span>) ? 1 : -1;</span></span><br><span class="line"><span class="function">    &amp;#125;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">function</span>(<span class="params">a,b</span>)&amp;#123;</span></span><br><span class="line">        a = a[attr];</span><br><span class="line">        b = b[attr];</span><br><span class="line">        if(a &lt; b)&amp;#123;</span><br><span class="line">            <span class="keyword">return</span> rev * <span class="number">-1</span>;</span><br><span class="line">        &amp;#125;</span><br><span class="line">        if(a &gt; b)&amp;#123;</span><br><span class="line">            <span class="keyword">return</span> rev * <span class="number">1</span>;</span><br><span class="line">        &amp;#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &amp;#125;</span><br><span class="line">&amp;#125;</span><br></pre></td></tr></table></figure></p>
<p>使用方式：</p>
<p>newArray.sort(sortBy(‘number’,false)) </p>
</blockquote>
<font color="purple" size="3"><strong>ps:sort当对含有多个对象的数组进行排序不输入函数时</strong></font><br>&gt; 默认对每个对象的属性值按照首字母的ASCII码顺序排列，如果首字母相同就比较第二个字符，而不会对对象排序。<br><br>=====================================================================================<br><br>####PS：with语句性能的因素：<br>&gt;- 再借地方放俩链：以V8为例，V8在Crankshaft编译架构下有两个JIT编译器，一个简单、不怎么优化的（叫做full-codegen），另外一个是优化编译器。优化编译器在把JavaScript AST parse成IR时如果看到with语句就直接放弃优化编译这个函数：bailout-reason.hhydrogen.cc 就跟vc大神说的一样。<br>&gt;<br>&gt; - Contra: The with statement forces the<br>specified object to be searched first for all name lookups. Therefore<br>all identifiers that aren’t members of the specified object will be<br>found more slowly in a ‘with’ block. Where performance is important,<br>‘with’ should only be used to encompass code blocks that access members<br> of the specified object.简单说，就是由于使用了with，对于所有变量查找，都会先在with指定的对象域内查找，查找失败，才会按照原JS标准作用域路径查找，因此，导致大量查找可能失败，但查找是很耗费性能的。<br>&gt;<br><br><br><br>=====================================================================================<br>####PS：深入解析作用域<br>&gt;简单地说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域分为全局和局部两种。<br>拥有全局作用域就是在代码任何地方都能够访问到，叫做全局变量，以下三种情况可以拥有<br>全局作用域<br><br>&gt;最外层函数和最外层函数外面定义的变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[html] view plain copy</span><br><span class="line"><span class="keyword">var</span> name=<span class="string">"brizer"</span>;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)&amp;#123;  </span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">realname</span>="<span class="title">lf</span>";  </span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">innerSay</span>(<span class="params"></span>)&amp;#123;  </span></span><br><span class="line"><span class="function">        <span class="title">alert</span>(<span class="params">realname</span>);  </span></span><br><span class="line"><span class="function">    &amp;#125;  </span></span><br><span class="line"><span class="function">    <span class="title">innerSay</span>(<span class="params"></span>);  </span></span><br><span class="line"><span class="function">&amp;#125;  </span></span><br><span class="line"><span class="function"><span class="title">document</span>.<span class="title">write</span>(<span class="params">name</span>); //<span class="title">brizer</span>  </span></span><br><span class="line"><span class="function"><span class="title">document</span>.<span class="title">write</span>(<span class="params">realname</span>); //脚本错误  </span></span><br><span class="line"><span class="function"><span class="title">doSomething</span>(<span class="params"></span>); //<span class="title">lf</span>  </span></span><br><span class="line"><span class="function"><span class="title">innerSay</span>(<span class="params"></span>) //脚本错误</span></span><br></pre></td></tr></table></figure><br><br>未定义直接赋值的变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[html] view plain copy</span><br><span class="line"><span class="comment">/*全局作用域2：*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)&amp;#123;  </span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">name</span>="<span class="title">brizer</span>";  </span></span><br><span class="line"><span class="function">    <span class="title">realname</span>="<span class="title">lf</span>";  </span></span><br><span class="line"><span class="function">    <span class="title">document</span>.<span class="title">write</span>(<span class="params">name</span>);  </span></span><br><span class="line"><span class="function">&amp;#125;  </span></span><br><span class="line"><span class="function"><span class="title">doSomething</span>(<span class="params"></span>); //<span class="title">brizer</span>  </span></span><br><span class="line"><span class="function"><span class="title">document</span>.<span class="title">write</span>(<span class="params">realname</span>); //<span class="title">lf</span></span></span><br></pre></td></tr></table></figure><br><br>&gt;所有window对象：<br>一般情况下，所有window对象的内置属性都拥有全局作用域，如window.location等。<br><br>&gt;局部作用域<br>&gt;局部作用域只在固定的代码片段内可访问到。<br>如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[html] view plain copy</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)&amp;#123;  </span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">name</span>="<span class="title">lf</span>";  </span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">innerSay</span>(<span class="params"></span>)&amp;#123;  </span></span><br><span class="line"><span class="function">        <span class="title">alert</span>(<span class="params">name</span>);  </span></span><br><span class="line"><span class="function">    &amp;#125;  </span></span><br><span class="line"><span class="function">    <span class="title">innerSay</span>(<span class="params"></span>);  </span></span><br><span class="line"><span class="function">&amp;#125;  </span></span><br><span class="line"><span class="function"><span class="title">alert</span>(<span class="params">name</span>); //脚本错误  </span></span><br><span class="line"><span class="function"><span class="title">innerSay</span>(<span class="params"></span>); //脚本错误</span></span><br></pre></td></tr></table></figure><br><br>&gt;函数作用域<br>这里把函数作用域单独提出来讲并不是因为它和局部还有全局是平级关系，而是由于其比较特殊。javascript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里。这是javascript权威指南中的一句话，相当经典。<br>举个例子说，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[html] view plain copy</span><br><span class="line"><span class="comment">//函数运行在它们被定义的作用域里,而不是它们被执行的作用域  </span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'lf'</span>;  </span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">echo</span>(<span class="params"></span>) &amp;#123;  </span></span><br><span class="line"><span class="function">          <span class="title">document</span>.<span class="title">write</span>(<span class="params">name</span>);  </span></span><br><span class="line"><span class="function">     &amp;#125;  </span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">     <span class="title">function</span> <span class="title">env</span>(<span class="params"></span>) &amp;#123;  </span></span><br><span class="line"><span class="function">          <span class="title">var</span> <span class="title">name</span> = '<span class="title">brizer</span>';  </span></span><br><span class="line"><span class="function">          <span class="title">echo</span>(<span class="params"></span>);  </span></span><br><span class="line"><span class="function">     &amp;#125;  </span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">     <span class="title">env</span>(<span class="params"></span>);</span></span><br></pre></td></tr></table></figure><br><br>&gt;最后结果的lf而不是brizer。说明函数在定义时，它的作用域就已经决定了。<br>作用域链<br>下面我们说说作用域链，在javascript中，函数也是对象，实际上，javascript中的一切都是对象。函数内部有一个只给javascript引擎访问的内部属性是[[scope]]，该属性包含了函数创建时的作用域中对象的集合，这个集合就叫做作用域链。<br><br>比如下面代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[html] view plain copy</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>) &amp;#123;  </span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">sum</span> = <span class="title">num1</span> + <span class="title">num2</span>;  </span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">sum</span>;  </span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br></pre></td></tr></table></figure><br><br>&gt;在函数创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量，如下图：<br><br>&gt;当函数被执行时，会创建一个活动对象，该对象包含了函数所有局部变量、命名参数以及this，然后该对象会被推入作用域链的前端，当函数执行完毕，该对象也随之销毁。如下图：<br><br>&gt;可以看到，全局变量会被活动对象推到作用域链的最后端，这也就是为什么全局变量访问速度慢的原因！<br><br>&gt;with<br>一般情况下，作用域链只会被with和catch语句影响。当使创建用with的时候，函数会创建一个新的活动对象，推到最前端，该对象就是with的对象。这就意味着所有的局部变量都处于第二个作用域链对象中去了，这也就是为什么要避免使用with的原因。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[html] view plain copy</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initUI</span>(<span class="params"></span>)&amp;#123;  </span></span><br><span class="line"><span class="function">    <span class="title">with</span>(<span class="params">document</span>)&amp;#123;  </span></span><br><span class="line"><span class="function">        <span class="title">var</span> <span class="title">bd</span>=<span class="title">body</span>,  </span></span><br><span class="line"><span class="function">            <span class="title">links</span>=<span class="title">getElementsByTagName</span>(<span class="params"><span class="string">"a"</span></span>),  </span></span><br><span class="line"><span class="function">            <span class="title">i</span>=0,  </span></span><br><span class="line"><span class="function">            <span class="title">len</span>=<span class="title">links</span>.<span class="title">length</span>;  </span></span><br><span class="line"><span class="function">        <span class="title">while</span>(<span class="params">i &lt; len</span>)&amp;#123;  </span></span><br><span class="line"><span class="function">            <span class="title">update</span>(<span class="params">links[i++]</span>);  </span></span><br><span class="line"><span class="function">        &amp;#125;  </span></span><br><span class="line"><span class="function">        <span class="title">getElementById</span>(<span class="params"><span class="string">"btnInit"</span></span>).<span class="title">onclick</span>=<span class="title">function</span>(<span class="params"></span>)&amp;#123;  </span></span><br><span class="line"><span class="function">            <span class="title">doSomething</span>(<span class="params"></span>);  </span></span><br><span class="line"><span class="function">        &amp;#125;;  </span></span><br><span class="line"><span class="function">    &amp;#125;  </span></span><br><span class="line"><span class="function">&amp;#125; </span></span><br><span class="line"><span class="function">``` </span></span><br><span class="line"><span class="function">=====================================================================================</span></span><br><span class="line"><span class="function">&gt;  ####**关于全局变量访问变慢的问题实验：**</span></span><br><span class="line"><span class="function">``` <span class="title">javascript</span></span></span><br><span class="line"><span class="function">	<span class="title">var</span> <span class="title">i</span> = 3;</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">obj</span> = &amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">num</span>: 1,</span></span><br><span class="line"><span class="function">        <span class="title">age</span>: 2</span></span><br><span class="line"><span class="function">    &amp;#125;</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">Fn</span>(<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">var</span> <span class="title">a</span> = 9;</span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">a</span>;</span></span><br><span class="line"><span class="function">    &amp;#125;</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">time</span>(<span class="params"><span class="string">"test1"</span></span>);</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">log</span>(<span class="params">i</span>);</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">timeEnd</span>(<span class="params"><span class="string">"test1"</span></span>);</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">time</span>(<span class="params"><span class="string">'test2'</span></span>);</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">log</span>(<span class="params">obj.num</span>);</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">timeEnd</span>(<span class="params"><span class="string">"test2"</span></span>);</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">time</span>(<span class="params"><span class="string">'test3'</span></span>)</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">log</span>(<span class="params">Fn(</span>));</span></span><br><span class="line"><span class="function">    <span class="title">console</span>.<span class="title">timeEnd</span>(<span class="params"><span class="string">'test3'</span></span>);</span></span><br></pre></td></tr></table></figure><br><br><img src="./1501915356396.png" alt="Alt text"><br><br><strong><font size="5">疑问</font></strong>：<br>&gt;当把全局变量注释掉不显示以后，obj局部变量的访问会大大减慢，不知道原因。。。<br><br><img src="./1501915145731.png" alt="Alt text"><br><br><br>=====================================================================================<br>####<strong>call、apply和bind</strong><br><br>&gt; 回想起之前的一些面试，几乎每次都会问到一个js中关于call、apply、bind的问题，比如…<br><br>&gt; 怎么利用call、apply来求一个数组中最大或者最小值<br><br>&gt; 如何利用call、apply来做继承<br><br>&gt;apply、call、bind的区别和主要应用场景<br><br>&gt;虽然网上有很多关于这方面的博客和文章，但还是决定写一篇自己对这方面知识的理解。<br><br><br>01-作用<br>&gt;首先问个问题，这三个函数的存在意义是什么？答案是改变函数执行时的上下文，再具体一点就是改变函数运行时的this指向。有了这个认识，接下来我们来看一下，怎么使用这三个函数。<br><br>&gt;举个栗子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)&amp;#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">this</span>.<span class="title">name</span> = <span class="title">name</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Person</span>.<span class="title">prototype</span> = &amp;#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">constructor</span>: <span class="title">Person</span>,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">showName</span>: <span class="title">function</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span>(<span class="params">this.name</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">person</span> = <span class="title">new</span> <span class="title">Person</span>(<span class="params"><span class="string">'qianlong'</span></span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">person</span>.<span class="title">showName</span>(<span class="params"></span>);</span></span><br></pre></td></tr></table></figure><br><br>上面的代码中person调用showName方法后会在浏览器的控制台输出qianlong<br><br>接下来<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var animal = &amp;#123;</span><br><span class="line"></span><br><span class="line">name: <span class="string">'cat'</span></span><br><span class="line"></span><br><span class="line">&amp;#125;</span><br></pre></td></tr></table></figure><br><br>上面代码中有一个对象字面量，他没有所谓的showName方法，但是我还是想用？怎么办？(坑爹了，这好像在让巧媳妇去做无米之炊)，不过没关系，call、apply、bind可以帮我们干这件事。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 call</span></span><br><span class="line"></span><br><span class="line">person.showName.call(animal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 apply</span></span><br><span class="line"></span><br><span class="line">person.showName.apply(animal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 bind</span></span><br><span class="line"></span><br><span class="line">person.showName.bind(animal)();</span><br></pre></td></tr></table></figure><br><br>啦啦啦，有木有很神奇，控制台输出了三次cat<br><br>我们拿别人的showName方法，并动态改变其上下文帮自己输出了信息，说到底就是实现了复用<br><br><br>02-区别<br><br>&gt;上面看起来三个函数的作用差不多，干的事几乎是一样的，那为什么要存在3个家伙呢，留一个不就可以。所以其实他们干的事从本质上讲都是一样的动态的改变this上下文,但是多少还是有一些差别的..<br><br>&gt;call、apply与bind的差别<br><br>&gt;call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数。<br><br>&gt;call、apply的区别<br><br>&gt;他们俩之间的差别在于参数的区别，call和aplly的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。<br><br>&gt;fn.call(obj, arg1, arg2, arg3…);<br><br>&gt;fn.apply(obj, [arg1, arg2, arg3…]);<br><br>03-应用<br><br>&gt;知道了怎么使用和他们之间的区别，接下来我们来了解一下通过call、apply、bind的常见应用场景。<br><br>&gt;求数组中的最大和最小值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">-67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">-8</span>,<span class="number">687</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>, <span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">-67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">-8</span>,<span class="number">687</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, arr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.min.call(<span class="built_in">Math</span>, <span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">-67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">-8</span>,<span class="number">687</span>);</span><br></pre></td></tr></table></figure><br><br>&gt;将伪数组转化为数组<br><br>&gt;js中的伪数组(例如通过document.getElementsByTagName获取的元素)具有length属性，并且可以通过0、1、2…下标来访问其中的元素，但是没有Array中的push、pop等方法。我们可以利用call、apply来将其转化为真正的数组这样便可以方便地使用数组方法了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arrayLike = &amp;#123;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: <span class="string">'qianlong'</span>,</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>: <span class="string">'ziqi'</span>,</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>: <span class="string">'qianduan'</span>,</span><br><span class="line"></span><br><span class="line">length: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">&amp;#125;</span><br></pre></td></tr></table></figure><br><br>&gt;上面就是一个普通的对象字面量，怎么把它变成一个数组呢？最简单的方法就是<br><br>&gt;var arr = Array.prototype.slice.call(arrayLike);<br><br>&gt;上面arr便是一个包含arrayLike元素的真正的数组啦( 注意数据结构必须是以数字为下标而且一定要有length属性 )<br><br>&gt;数组追加<br><br>&gt;在js中要往数组中添加元素，可以直接用push方法，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">[].push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr1 [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2 [4,5,6]</span></span><br></pre></td></tr></table></figure><br><br>&gt;判断变量类型<br><br>&gt;对于对象型的数据类型，我们可以借助call来得知他的具体类型，例如数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>)&amp;#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">return Object.prototype.toString.call(obj) == '[object Array]';</span><br><span class="line"></span><br><span class="line">&amp;#125;</span><br><span class="line"></span><br><span class="line">isArray([]) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">isArray(<span class="string">'qianlong'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><br><br>=====================================================================================<br>####<strong>DOM的映射</strong><br>        通过DOM方法获取的一个元素集合(类数组),这个集合仍然和页面的元素保持着联系,并且这个元素集合会随着页面元素的增加而增加,减少而减少,即使把这个数组转为一个新数组,每个元素仍然和页面有联系,这就叫做”DOM映射”<br>–<br><br>&gt;回流:<br>元素的<font color="red">位置发生改变</font>(增加元素,删除元素,移动)引起回流,让整个页面重新渲染一遍,从而造成性能浪费<br>–<br><br>重绘:<br>元素<font color="red">样式发生改变</font>,就会把当前这个元素重新渲染一遍所以在以后项目中,能用重绘代替的就不用回流,能用一次回流就不用使用多次<br>–<br><br>向页面增加元素的方式<br><br>1.动态创建的方式document<br>.document.createElement,然后一个一个appendChild,会造成多次回流,这样不好,但是他有个好处是不会改变原来的元素(比如不会影响他之前绑定的事件);<br><br>2.通过拼接字符串,最后在一次性通过innerHTML,这样只会引起一次回流,这样比较好,但是他会改变原来的元素(比如会影响之前绑定的事件);<br><br>3.关键点!”文档碎片”,他就是个容器专门来盛放DOM元素的<br>例子:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flg=<span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    for (var i=0;i&lt;jsonData.length;i++)&amp;#123;</span><br><span class="line">        <span class="keyword">var</span> oli=<span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">        oli.innerHTML=jsonData[i].content;</span><br><span class="line">        oli.className=jsonData[i].class;</span><br><span class="line">        flg.appendChild(oli);</span><br><span class="line">    &amp;#125;</span><br><span class="line">    news.appendChild(flg);</span><br><span class="line">    flg=<span class="literal">null</span>;<span class="comment">//用完了 没有用了，就清空</span></span><br><span class="line">&amp;#125;</span><br></pre></td></tr></table></figure><br><br>步骤:<br>1.先给创建元素 var oli=document.createElement(“li”)<br>2.按需求给元素增加一些需要的属性<br>3.暂时存放在flg(DOM碎片)中,也是appendChild进去的<br>4.循环完之后,把整flg放到ul中,news.appendChild(flg)<br>这样就只会引起一次回流<br><br>=====================================================================================<br><br>####<strong>localcompare问题</strong><br>1.ES5中localcompare方法的实现原理：<br>&gt;String.prototype.localeCompare (that)<br><br> &gt;当以一个参数 that 来调用 localeCompare 方法，它返回一个非 NaN 数字值，这个数字值反应了对 this 值（转换为字符串）和 that 值（转换为字符串）进行语言环境敏感的字符串比较的结果。两个字符串 S 和 That 用实现定义的一种方式进行比较。比较结果是为了按照系统默认语言环境指定的排列顺序来排列字符串，根据按照排列顺序 S 是在 That 前面，相同，还是 S 在 That 后面，结果分别是负数，零，正数。<br><br> &gt;在执行比较之前执行以下步骤以预备好字符串：<br><br>&gt;以 this 值作为参数调用 CheckObjectCoercible。<br>&gt;令 S 为以 this 值作为参数调用 ToString 的结果 .<br>令 That 为 ToString(that).<br>&gt; 如果将 localeCompare 方法看做是将 this 和 that 作为两个参数的函数，那么它是在所有字符串集合上的保持一致的比较函数（在 15.4.4.11 定义）。<br><br> &gt;实际返回值是实现定义的，允许实现者们在返回值里编码附加信息。但是函数需要定义一个在所有字符串上的总的顺序，并且，当比较的字符串们被认为是 Unicode 标准定义的标准等价，则返回 0。<br><br>&gt; 如果宿主环境没有在所有字符串上语言敏感(<strong>可能指的是除了英语以外的象形文字</strong>)的比较，此函数可执行按位比较。<br><br>&gt;localeCompare 方法自身不适合直接作为 Array.prototype.sort 的参数，因为后者需要的是两个参数的函数。<br><br>&gt;这个函数的目的是在宿主环境中任何依靠语言敏感的比较方式都可用于 ECMAScript 环境，并根据宿主环境当前语言环境设置的规则进行比较。强烈建议这个函数将 – 根据 Unicode 标准的标准等价的 – 字符串当做是相同的（也就是说，要比较的字符串仿佛是都先被转换为正常化形式 C 或正常化形式 D 了）。还建议这个函数不履行 Unicode 相容等价或分解。<br><br>&gt;本标准的未来版本可能会使用这个函数的第二个参数；建议实现不将这个参数位用作其他用途。<br><br>&gt;localeCompare 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。<br><br>=====================================================================================<br>####<strong>关于使用汉字拼音使用localecompare出现不按期望顺序排列的问题研究</strong><br><strong>可能的原因及经过测试可行的方法(暂时看不太懂包括（<font color="purple">可能包括C#）)</font></strong><br>&gt;1.一般来说，人们将使用以下方法进行汉字拼音排序<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list=[<span class="string">' king '</span>, <span class="string">'a'</span>, <span class="string">'li'</span>];  </span><br><span class="line">list.Sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) &amp;#123;<span class="title">return</span> <span class="title">a</span>.<span class="title">localeCompare</span>(<span class="params">b</span>); &amp;#125;);</span></span><br><span class="line"><span class="function"><span class="title">localeCompare</span>（）：具有本地特定的顺序来比较两个字符串。</span></span><br></pre></td></tr></table></figure><br><br>&gt;拼音排序的方法是不可靠的。<br><br>&gt;第二种方式：非常依赖中文操作系统<br><br>&gt;非常依赖浏览器内核，就是说，如果你的网站访问者是通过中文系统，或浏览器浏览器（Chrome），那么他可能无法看到拼音排序我们预期的结果。<br><br>&gt;<strong>重写的compare方法来实现的localcompare</strong>   在这里，我将介绍我的解决方案，希望能够得到某种方式：这个方法支持从0到0 x9fa5区域的Unicode字符集x4e00从中国（包括台湾），日本，韩国，汉字，即日本汉字（CJK）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var CompareStrings=&amp;#123;.........&amp;#125;</span><br><span class="line">getOrderedUnicode: <span class="function"><span class="keyword">function</span> (<span class="params">char</span>) &amp;#123;</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">originalUnicode</span>=<span class="title">char</span>.<span class="title">charCodeAt</span> (<span class="params"></span>); </span></span><br><span class="line"><span class="function"><span class="title">if</span> (<span class="params">originalUnicode &gt;=<span class="number">0</span> x4e00 &amp;&amp; originalUnicode &lt;=<span class="number">0</span> x9fa5</span>) &amp;#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//判断字符的<span class="title">unicode</span>码是否在中文的范围 4<span class="title">E00</span>-9<span class="title">FA5</span>内。</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">index</span>=<span class="title">this</span>.<span class="title">Db</span>.<span class="title">IndexOf</span> (<span class="params">char</span>); </span></span><br><span class="line"><span class="function"><span class="title">if</span> (<span class="params">index &gt;<span class="number">1</span></span>) &amp;#123;</span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="title">index</span> + 0 <span class="title">x4e00</span>; </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&amp;#125;&amp;#125; </span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="title">originalUnicode</span>; </span></span><br><span class="line"><span class="function">&amp;#125;, </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">compare</span>: <span class="title">function</span> (<span class="params">a, b</span>) &amp;#123;</span></span><br><span class="line"><span class="function"><span class="title">if</span> (<span class="params">a==b</span>) &amp;#123;<span class="title">return</span> 0; &amp;#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//<span class="title">here</span> <span class="title">can</span> <span class="title">be</span> <span class="title">rewritten</span> <span class="title">according</span> <span class="title">to</span> <span class="title">the</span> <span class="title">specific</span> <span class="title">needs</span> <span class="title">and</span> <span class="title">the</span> <span class="title">writing</span> <span class="title">is</span> <span class="title">the</span> <span class="title">empty</span> <span class="title">string</span> <span class="title">at</span> <span class="title">the</span> <span class="title">bottom</span> <span class="title">the</span> <span class="title">if</span> (<span class="params">a.length==<span class="number">0</span></span>) &amp;#123;<span class="title">return</span> 1; &amp;#125; </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">if</span> (<span class="params">b.length==<span class="number">0</span></span>) &amp;#123;<span class="title">return</span> - 1; &amp;#125; </span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">count</span>=<span class="title">a</span>.<span class="title">length</span> &gt;<span class="title">B</span>.<span class="title">length</span>? <span class="title">B</span>.<span class="title">length</span>: <span class="title">a</span>.<span class="title">length</span>; </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">for</span> (<span class="params">var i=<span class="number">0</span>; i&lt;count; i++</span>) &amp;#123;</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">au</span>=<span class="title">this</span>.<span class="title">GetOrderedUnicode</span> (<span class="params">a [i]</span>); </span></span><br><span class="line">var bu=this.GetOrderedUnicode [i] (b); </span><br><span class="line">if (au &gt;bu) &amp;#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&amp;#125; else if (au &lt;bu) &amp;#123;</span><br><span class="line"><span class="keyword">return</span> - <span class="number">1</span>; </span><br><span class="line">&amp;#125;&amp;#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a.length &gt;B.length? <span class="number">1</span>:<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&amp;#125;&amp;#125; </span><br><span class="line"><span class="comment">//rewriting system native localeCompare</span></span><br></pre></td></tr></table></figure><br><br>&gt;原型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocaleCompare = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) &amp;#123;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">CompareStrings</span>.<span class="title">compare</span> <span class="title">said</span> (<span class="params">enclosing the toString (</span>), <span class="title">param</span>); </span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br></pre></td></tr></table></figure><br><br>&gt;您可以通过以下链接下载完整的代码<br><br>&gt;简要介绍实施原则：<br><br>&gt;根据拼音排序好字符（db）：有多种方式来实现一个目标，我完成了JavaScript + c＃组合，使用脚本首先把所有的汉字列举，然后提交到c #good背景排序，并输出到前台，这只是准备，什么都可以。<br>&gt;识别两个较大的字符（getOrderedUnicode）：因为在派寻时，不仅要处理汉字和汉字外的字符，所以比较器必须能够识别所有的字符，我们这里通过判断一个字符是区分汉字：如果是汉字，那么排序好的字库搜索索引，索引值加上Unicode字符设置第一个汉字的位置，是在“校准”后的Unicode字符集指数值 如果不是汉字，则直接在Unicode字符集的索引值上返回。<br>&gt;比较两个字符串（比较）：通过比较两个字符（在有效范围比较中，即字符串的长度越短），如果发现大于b，则返回1，副返回1。<br>&gt;在比较之后的有效范围内，如果没有领带，只要看谁是更长的，比如a =’123’，b =’1234’，那么长b在后面排。<br>编辑<br><br>&gt;你也可以使用JQuery插件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend( jQuery.fn.dataTableExt.oSort, &amp;#123;</span><br><span class="line">    <span class="string">"chinese-string-asc"</span> : <span class="function"><span class="keyword">function</span> (<span class="params">s1, s2</span>) &amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">s1</span>.<span class="title">localeCompare</span>(<span class="params">s2</span>);</span></span><br><span class="line"><span class="function">    &amp;#125;,</span></span><br><span class="line"><span class="function">    "<span class="title">chinese</span>-<span class="title">string</span>-<span class="title">desc</span>" : <span class="title">function</span> (<span class="params">s1, s2</span>) &amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">s2</span>.<span class="title">localeCompare</span>(<span class="params">s1</span>);</span></span><br><span class="line"><span class="function">    &amp;#125;</span></span><br><span class="line"><span class="function">&amp;#125; );</span></span><br></pre></td></tr></table></figure><br><br>&gt;2. 中文拼音只有gb2312一级字库的汉字是按拼音组织的<br>所以你当按汉字内码排序时，并不都符合拼音顺序<br><br><br>&gt;存在的疑问：<br>1.在chorme下测试，经过测试’沈’和’陈’比较显示-1，意思是沈在陈前面，但是沈的首字母是s，陈的是c所以不是按照常规首字母排序，经过查找发现沈的Unicode码沈的是\u6c88，而陈的是\u9648，按照这个逻辑是-1，但是测试另外一组’赵’和’钱’的Unicode码分别是\u8d75和\u94b1，按照unicode码的顺序返回的该是-1，但事实是1，所以证明排序规则并不是完全按照Unicode码中的顺序，参照MDN关于localecompare的文档，localeCompare() 方法提供的比较字符串的方法，考虑了默认的本地排序规则。ECMAscript 标准并没有规定如何进行本地特定的比较操作，它只规定该函数采用<font color="red">底层操作系统提供的排序规则。所以对这个操作系统的底层排序规则暂时查不明白。<br><br><br>=====================================================================================<br><br>####<strong>关于使用文档碎片向页面中添加内容和直接向页面添加内容所耗性能的实验</strong><br><br>1.已知后者肯定会导致一次dom回流或者多次dom重绘，对于文档碎片是否会导致dom回流尚不确定，暂且认为其也会导致一次dom回流。思路是利用：console.time，在数据向页面绑定代码段测试使用直接向页面添加和利用文档碎片添加的所耗时间。<br>统计100次：<br>- 使用文档碎片结果：大部分结果在0.08ms到0.47ms之间，期间有两次出现2.27ms和3.96ms（认为是特殊情况。）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'test'</span>);</span><br><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">sortRows</span>(<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function">    //-&gt;把存储所有行的类数组转换为数组(<span class="params">只有数组才能用SORT方法进行排序</span>)</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">stuRowsAry</span> = <span class="title">utils</span>.<span class="title">toArray</span>(<span class="params">stuRows</span>);</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">_this</span>=<span class="title">this</span>;</span></span><br><span class="line"><span class="function">    //-&gt;让所有的行按照年龄这一列由小到大排序</span></span><br><span class="line"><span class="function">    <span class="title">stuRowsAry</span>.<span class="title">sort</span>(<span class="params">function (a, b</span>) &amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">var</span> <span class="title">curAge</span> = <span class="title">parseFloat</span>(<span class="params">a.cells[<span class="number">2</span>].innerHTML</span>);</span></span><br><span class="line"><span class="function">        <span class="title">var</span> <span class="title">nextAge</span> = <span class="title">parseFloat</span>(<span class="params">b.cells[<span class="number">2</span>].innerHTML</span>);</span></span><br><span class="line"><span class="function">        <span class="title">return</span> (<span class="params">curAge - nextAge</span>)*<span class="title">_this</span>.<span class="title">n</span>;</span></span><br><span class="line"><span class="function">    &amp;#125;);</span></span><br><span class="line"><span class="function">    //-&gt;按照数组排好的顺序,我们把每一行重新的放入到页面中,让页面中的结构也跟着排序</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">frg</span> = <span class="title">document</span>.<span class="title">createDocumentFragment</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function">    <span class="title">for</span> (<span class="params">var i = <span class="number">0</span>; i &lt; stuRowsAry.length; i++</span>) &amp;#123;</span></span><br><span class="line">        var curRow = stuRowsAry[i];</span><br><span class="line">        frg.appendChild(curRow);</span><br><span class="line">    &amp;#125;</span><br><span class="line">    stuBody.appendChild(frg);</span><br><span class="line">    frg = <span class="literal">null</span>;</span><br><span class="line">&amp;#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure><br><br>- 直接向页面容器添加：<br>- 统计100次：<br>-  直接向页面添加元素结果：大部分结果在0.08到0.45之间，期间没有出现超过1ms的情况，仅发现一次0.58ms。<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">console</span>.time(<span class="string">'test'</span>);</span><br><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">sortRows</span>(<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function">    //-&gt;把存储所有行的类数组转换为数组(<span class="params">只有数组才能用SORT方法进行排序</span>)</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">stuRowsAry</span> = <span class="title">utils</span>.<span class="title">toArray</span>(<span class="params">stuRows</span>);</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">_this</span>=<span class="title">this</span>;</span></span><br><span class="line"><span class="function">    //-&gt;让所有的行按照年龄这一列由小到大排序</span></span><br><span class="line"><span class="function">    <span class="title">stuRowsAry</span>.<span class="title">sort</span>(<span class="params">function (a, b</span>) &amp;#123;</span></span><br><span class="line"><span class="function">        <span class="title">var</span> <span class="title">curAge</span> = <span class="title">parseFloat</span>(<span class="params">a.cells[<span class="number">2</span>].innerHTML</span>);</span></span><br><span class="line"><span class="function">        <span class="title">var</span> <span class="title">nextAge</span> = <span class="title">parseFloat</span>(<span class="params">b.cells[<span class="number">2</span>].innerHTML</span>);</span></span><br><span class="line"><span class="function">        <span class="title">return</span> (<span class="params">curAge - nextAge</span>)*<span class="title">_this</span>.<span class="title">n</span>;</span></span><br><span class="line"><span class="function">    &amp;#125;);</span></span><br><span class="line"><span class="function">    //-&gt;按照数组排好的顺序,我们把每一行重新的放入到页面中,让页面中的结构也跟着排序</span></span><br><span class="line"><span class="function">    // <span class="title">var</span> <span class="title">frg</span> = <span class="title">document</span>.<span class="title">createDocumentFragment</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function">    <span class="title">for</span> (<span class="params">var i = <span class="number">0</span>; i &lt; stuRowsAry.length; i++</span>) &amp;#123;</span></span><br><span class="line">        var curRow = stuRowsAry[i];</span><br><span class="line">        stuBody.appendChild(curRow);</span><br><span class="line">    &amp;#125;</span><br><span class="line">    <span class="comment">// stuBody.appendChild(frg);</span></span><br><span class="line">    <span class="comment">// frg = null;</span></span><br><span class="line">&amp;#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure><br><br>&gt; <font color="red"><strong>总结：</strong> </font><br>&gt; 经结果看来两者所耗时间几乎相同，只是似乎直接向页面容器添加元素的方法比文档碎片还要好那么一丢丢，关于文档碎片方法出现的以外高时长考虑可能为程序问题或者设备问题，此外，这次实验可能受到过多的外界原因和程序的编写不合理性影响，因为之前查看网络文档普遍认为文档碎片是一种较好的方式，至于为什么会出现这样的结果，暂时还想不出来，留到以后解决，暂时实验到这。哈哈。。。<br><br><br><br><br><br>&gt;知乎关于类似问题的讨论：<br><br><br>DocumentFragment真的能提高 JS 动态添加 DOM 的性能吗？<br>不知从何时起在网上看到过一篇博文提到利用DocumentFragment提高JS动态添加大量DOM的性能，主要论据是每次调用node.appendChild()都会引起 reflow，而通过先把 DOM 暂存在DocumentFragment，从而达到只需要一次 reflow的目的。<br>当时还是太年轻的我从此便奉为金科玉律。直到今天不知何故突然脑洞大开：在浏览器当中 JS 不是会阻塞 UI 的渲染吗，那为什么在一个循环里边动态添加多个 DOM 会引起多次 reflow 呢？这明显不科学嘛，此时 UI 应该是被 blocked 才对。。<br><br>于是我写了一些代码来测试我的想法。。<br><br><br>测试结果发现时间基本无差别。。难道是现在的浏览器高端到 JS 不会阻塞 UI 渲染了吗？于是我又写了些代码。。<br><br>测试结果是 JS 还是会阻塞 UI 的，于是我迷茫了。。求大神答疑解惑~~<br><br><br>&gt; 回答1：<br>&gt;题主你怎么从写的第二段代码得出“JS 不会阻塞 UI 渲染了”的看法的？有些事情只在节点被插入到真正的document时才发生，这是document fragment更快的基本原因。document fragment从机制上比较接近innerHTML，只是前者确保了dom结构。其他大量的事情其实要等到被插入document之后才发生。比如当你append到document时，被append进去的元素的样式表的计算是同步发生的，此时getComputedStyle可以得到样式的计算值。而append到document fragment，没样式表什么事，可以省下这个计算。再如，script节点只有append到document时，才会真的parse和执行。注意阻塞UI不是阻塞reflow。如果你在append到document之后去访问下clientHeight这样的属性，其实会block住直到reflow完成。但是如果你不访问这类属性，浏览器没有必要在这个点进行强制reflow，而可以等待到脚本执行完。现代浏览器的优化做得更好，所以类似的，如果你在append到document之后没有访问getComputedStyle之类的，浏览器也可以把样式表计算推迟到脚本执行之后。所以你测下来 append 到 document fragment 和直接 append 到 document 上就差不多了。尽管通常情况下，性能现在没有很大差异，但是作为靠谱程序员，你在追加dom时，用document fragement，是在代码层面明确：这里插入时，不需要（不应该）发生插入document的效果。所以该写的地方还是要写。<br><br><br>&gt; 回答2：早期，人们每次循环都把拼好的DIV  append到浏览器DOM中一个container里，比如JS写一个500次的循环，浏览器每次都执行重排，这样重排了500次。人们发现500次重排计算让浏览器做实在太耗费性能了。于是人们想，为什么不把这500个DIV以DOM的方式在内存里事先做好，然后一次append到浏览器里，这样浏览器一次处理的重排量虽然很大，但是比500次的小型重排的效率要快得多<br><br>&gt; 回答3：我记得在v8引擎优化之后 这些奇技淫巧往往会让实际速度变慢 （<font color="red">具体不知道真假）<br><br><br><br><br><br>=====================================================================================<br><br>####<strong>PS:for循环应注意的问题</strong><br><br>&gt;如果您希望一遍又一遍地运行相同的代码，并且每次的值都不同，那么使用循环是很方便的。<br>很多时候我们都用到for循环，而用到for循环部门往往对一个数组进行循环，其中我们很多时候都是这样写的：<br><img src="./1502162693702.png" alt="Alt text"><br><br>　　这样的代码虽然没有什么大问题，但是每次循环都会获取一下数组的长度，这回降低你的代码，尤其当myarray不是数组，而是一个HTMLCollection对象的时候。<br>再看看下面的这个代码：<br><img src="./1502162739963.png" alt="Alt text"><br><br><br>这样地代码只会获取一次数组的长度，提高了代码的质量；<br>伴随着单var形式，你可以把变量从循环中提出来，就像下面这样：<br><img src="./1502162766604.png" alt="Alt text"><br><br><br>javascript使用for循环时问题总结<br>这个问题的讨论最初来自公司内部邮件，我只是把这个问题的讨论内容记录下来。<br>有一些项目组在定位问题的时候发现，在使用“for(x in array)”这样的写法的时候，在IE浏览器下，x出现了非预期的值。<br>具体说，如果自定义了Array.prototype.indexOf方法（譬如源于某prototype污染），也许是因为老版本IE浏览器并不支持array.indexOf方法，而开发者又很想用，那么这样的浏览器可能会出现这样的问题：<br><img src="./1502162788094.png" alt="Alt text"><br>输出:<br><img src="./1502162804098.png" alt="Alt text"><br><br>换句话说，把indexOf这个方法给输出出来了。<br>解决方法很简单，要么别添加这个方法，要么用“for (i=0; i &lt; array.length; i++)”这样的循环等等。<br>但是问题的本质呢？有人猜测，可能是因为for(x in obj)这种用法其实是去遍历一个对象，而array的实现其实也和普通的object一致，只不过key是既定的数值而已：<br><img src="./1502162833510.png" alt="Alt text"><br><br><br>在一则stackoverflow的问答里面也提到了，遍历数组的时候用for…in和for(;;)的区别，前者的含义是枚举对象的属性，存在这样两个问题：<br>枚举的顺序无法被保证；<br>继承属性也被枚举出来；<br>在对Array.prototype.forEach的支持上，从这张表中也可以明确看到，IE8及以下版本是无法准确支持的：<br><br><img src="./1502162865617.png" alt="Alt text"><br><br>这里还有对forEach方法兼容性的详细阐述。事实上，主要的JavaScript框架（比如jQuery、Underscore和Prototype等等）都有安全和通用的for-each功能实现。<br>在JSLint的for in章节里面也提到，for in语句允许循环遍历对象的属性名，但是也会遍历到那些通过原型链继承下来的属性，这在很多情况下都会造成预期以外的错误。有一种粗暴的解决办法：<br><img src="./1502162893891.png" alt="Alt text"><br><br><br>还有人提到了使用for(var i=0;i<length;i++)类似这样的循环时的问题，因为javascript没有代码块级别的变量，所以这里的i的访问权限其实是所在的方法。有x的书上会建议程序员把这样的变量声明放到一处去，但是从直观性上说，在大部分情况下都不够合理。 使用javascript="" 1.7中引入的“let”可以解决这个问题，使i成为真正的代码块级别的变量：="" ![alt="" text](.="" 1502162923177.png)="" 最后，在google的javascript风格导引里面，也涉及到了这个约束：="" 1502162936117.png)="====================================================================================" ####**原型对象汇总**="" 1.关于原型对象的重要知识点="" 首先要知道一个很重要的知识点,一句话:所有对象都有原型对象.="" 2.="" 对比其他语言的理解="" 原型对象,就是其它语言中的类中的静态属性和静态方法,总是是静态-static就对了.原理是:="" 内存中只有一份.="" 3.="" 在内存中的形象图:="" 首先,在产生js对象之前,我们需要创造一个构造函数(这都不知道,那就不要往下看了),如下:="" <figure="" class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name_, age_</span>) &amp;#123;</span></span><br><span class="line"><span class="function">         <span class="title">this</span>.<span class="title">name</span> = <span class="title">name_</span>;</span></span><br><span class="line"><span class="function">         <span class="title">this</span>.<span class="title">age</span> = <span class="title">age_</span>;</span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br></pre></td></tr></table><br><br>下面,我们就要new 对象了,这里,我们new三个(Person)对象,”张三” “李雷” “韩梅梅”,他们来自同一个构造函数Person:<br><br><img src="./1502163550506.png" alt="Alt text"><br><br><br><br><br>内存中就这样了,每个对象,都有自己的 name, age 内存.这里new了多少个对象,就要开辟多少块name, age内存.<br><br>看到这,应该还是比较好理解的. 下面我们添加一条属性.location属性,如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name_, age_</span>) &amp;#123;</span></span><br><span class="line"><span class="function"><span class="title">this</span>.<span class="title">name</span> = <span class="title">name_</span>;</span></span><br><span class="line"><span class="function"><span class="title">this</span>.<span class="title">age</span> = <span class="title">age_</span>;</span></span><br><span class="line"><span class="function"><span class="title">this</span>.<span class="title">location</span> = "地球";</span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br></pre></td></tr></table></figure><br><br>这时候 我们在new这三个人. 内存情况如下:<br><img src="./1502163575063.png" alt="Alt text"><br><br><br>这里我们看,三个对象都有一个”地球”的内存空间.  这里你要动动大脑了, 三个人都有地球的内存,我们是不是可以这样呢?<br><br>你看这样好不好呢?  这样只需要一个地球,大家都可以用了.   看到这,好吧,公用的那个空间如果是个对象的话,就是所谓的原型对象了.就这样?<br>是的,就这样.<br><br>原型对象,最重要的作用就是把常量和方法独立到自身里.   供给其它 “自己的对象” 使用. 最后如图:<br><br> <img src="./1502163597440.png" alt="Alt text"><br><br><br>4. 从代码的层次上介绍原型对象.<br>上图是内存中的对象,我们现在从代码的从面操作.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name_, age_</span>) &amp;#123;</span></span><br><span class="line"><span class="function"><span class="title">this</span>.<span class="title">name</span> = <span class="title">name_</span>;</span></span><br><span class="line"><span class="function"><span class="title">this</span>.<span class="title">age</span> = <span class="title">age_</span>;</span></span><br><span class="line"><span class="function"><span class="title">this</span>.<span class="title">location</span> = "地球";</span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line"><span class="function">//  三个具体的对象</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">zhangsan</span> = <span class="title">new</span> <span class="title">Person</span>(<span class="params"><span class="string">"zhangsan"</span>, <span class="number">21</span></span>);</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">lilei</span> = <span class="title">new</span> <span class="title">Person</span>(<span class="params"><span class="string">"lilei"</span>, <span class="number">21</span></span>);</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">hanmeimei</span> = <span class="title">new</span> <span class="title">Person</span>(<span class="params"><span class="string">"hanmeimei"</span>, <span class="number">21</span></span>);</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">// 他们的原型对象是</span></span><br><span class="line"><span class="function"><span class="title">Person</span>.<span class="title">prototype</span>.<span class="title">location</span> = "地球";</span></span><br><span class="line"><span class="function"><span class="title">Person</span>.<span class="title">prototype</span>.<span class="title">killPerson</span> = <span class="title">function</span>(<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function">                                               <span class="title">return</span> "杀人";</span></span><br><span class="line"><span class="function">                                       &amp;#125;;</span></span><br></pre></td></tr></table></figure><br><br>这里有一个问题,我们知道原型对象,可是我们怎么访问到原型对象里的属性呢.  就是我们如何获取到location ,和用 killPerson方法呢?<br>请看:<br>         alert(zhangsan.location);<br>         alert(zhangsan.killPerson());<br><br>这样就可以访问到了,不过前提是,你的对象属性里面,没有定义location和killPerson.不然会把原对象的覆盖掉.   这里面涉及到原型问题即,<br>在zhangsan.location的时候,首先,我们检查zhangsan对象本身,从图中我们知道,张三有 name, age 和prototype指针属性.  并没有location,找不到以后,它会继续搜索原对象里面,看能否找到location属性,如果有,就会调用原对象的属性.<br><br>所以alert(zhangsan.location) 会输出   “地球”<br>alert(zhangsan.killPerson() ) 会输出   “杀人”<br><br><br><br><br><br><br><br><br>理解js的prototype原型对象<br>我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原受对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示。<br><img src="./1502163624964.png" alt="Alt text"><br><br><br><br>在此，我们将sayName()方法和所有属性直接添加到了Person的prototype属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说．personl和person2访问的都是同一组属性和同一个sayName()函数。要理解原型模式的T作原理，必须先理解ECMAScript巾原型对象的性质。<br><br>理解原型对象<br><br>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prot otype属性所在函数的指针。就拿前面的例子来说，Person.prototype. constructor措向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。<br>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Obj ect继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含—个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype】]。虽然在脚本中没有标准的方式访问【[ Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性—proto<em>;而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。<br>以前面使用Person构造函数和Person.prototype创建实例的代码为例，图6-1展示了各个对象之间的关系。<br> <img src="./1502163648019.png" alt="Alt text"><br><br><br><br><br><br><br><br>上图展示rr Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。在此，Person <em>prototype指向了原型对象，而Person.prototype.constructor叉指回了Person。原型对象中除了包含cons t,ruct or属性之外，还包括后来添加的其他属性。Person的每个实例personl和person2都包含一个内部属性，该属性仅仅指向了Person.prot otype;换句话说，它们与构造函数没有直接的关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用personl.sayName()。这是通过查找对象属性的过程来实现的。<br>虽然在所有实现中都无法访问到[[Prototype]：，但可以通过isProcotypeOf()方法来确定对象之间是否存在这种关系。从本质上讲，如果[[ Prototype]]指向调用isPrototypeOf()方法的对象[Person.prototype)．那么这个方法就返回true，如下所示：<br> <img src="./1502163666738.png" alt="Alt text"><br><br><br><br><br>这里，我们用原型对象的isPrototypeOf()方法测试了personl和person2 0因为它们内部都有一个指向Person.prototype的指针，因此都返回了true。<br><br>ECMAScript 5增加了一个新方法，叫Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[PrototypeJ]]的值。例如：<br> <img src="./1502163682791.png" alt="Alt text"><br><br><br><br>这里的第一行代码只是确定Object.getPrototypeOf()返回的对象实际就是这个对象的原型。第二行代码取得了原型对象中name属性的值，也就是’Nicholas’。使用Object.getPrototypeOf()可以方便地取得一个对象的原型，而这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的。支持这个方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera 12+和Chrome。<br>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用personl. sayName《）的时候，会先后执行两次搜索。首先，解析器会同：“实例personl有sayName属性吗？”答：“没有。”然后，它继续搜索，再问：“personl的原捌有sayName属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函数。当我们调用person2.sayName()时，将会重现相同的搜索过程，得到相同的结果。而这正是多个对象实例共享原型所保存的属性和方法的基本原理。<img src="./clipboard.png" alt="Alt text"><br><br>=====================================================================================<br><br><br><br>####<strong>对象直接量</strong><br><br>&gt;对象直接量提供了另一种创建新对象的方式。对象直接量允许将对象描述文字嵌入到JavaScript代码中，就像将文本数据嵌入在JavaScript代码中，就像将文本数据嵌入在JavaScript代码中作为引用的字符串一样。对象直接量是由属性说明列表构成的，这个列<br>表包含在大括号之中，其中的属性说明用逗号隔开。对象直接量中的每个属性说明列表都由一个属性名及跟在其后的冒号和属性值构<br>成。使用对象直接量创建对象的一般格式如下：<br>var myobject = &#123;属性名1:属性值1,属性2:属性值,…,属性名n:属性值n&#125;<br>       从这个定义中可以看出，这种定义方式实际上是声明一种类型的变量，并同时进行了赋值。因此，声明后的对象直接量可以<br>在代码中直接使用，而不必使用new关键字来创建对象。<br>此种方法只是创建了该对象的一个实例，如果要创建该对象的多个实例，需要将对象直接量写多遍。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var circle = &amp;#123;</span><br><span class="line"><span class="string">"x"</span>:<span class="number">0</span>,</span><br><span class="line">y:<span class="number">0</span>,</span><br><span class="line">radius:<span class="number">2</span>,</span><br><span class="line">alerttest:<span class="function"><span class="keyword">function</span>(<span class="params">mm</span>)&amp;#123;<span class="title">alert</span>(<span class="params">mm</span>);&amp;#125;,</span></span><br><span class="line"><span class="function"><span class="title">birthday</span>:</span></span><br><span class="line"><span class="function">  &amp;#123;<span class="title">year</span>:'1982年',<span class="title">month</span>:'2月',<span class="title">day</span>:'14日'&amp;#125;</span></span><br><span class="line"><span class="function">&amp;#125; </span></span><br><span class="line"><span class="function"><span class="title">document</span>.<span class="title">write</span>(<span class="params">circle.x + <span class="string">" "</span> + circle[<span class="string">"y"</span>] + <span class="string">" "</span> + circle.radius</span>); </span></span><br><span class="line"><span class="function"><span class="title">circle</span>.<span class="title">alerttest</span>(<span class="params"><span class="string">"elong"</span></span>);</span></span><br></pre></td></tr></table></figure><br><br>&gt;对象直接量和json，有人可以转换等等。 我经过测试，感觉现在浏览器已经爸他们当作一回事了。<br><br>&gt;最近研究一个fck时，发现在js的多语言实现时用到了直接量。<br><br>&gt;仔细一想真是聪明之极。<br>1.直接量有点想数组，key–value的形式组织。<br>2.当直接具体那个key时可以这样得到值：circle .key, 或者circle[“key”]. 前一种方式我更喜欢<br>3.当程序动态的取值时：circle[key].    key可以动态传入。<br><br><br>=====================================================================================<br><br><br>####<strong>栈内存和堆内存</strong><br>JS中栈内存和堆内存的区别：<br><br><br> 堆和栈这两个字我们已经接触多很多次，那么具体是什么存在栈中什么存在堆中呢？就拿JavaScript中的变量来说：<br>         首先JavaScript中的变量分为基本类型和引用类型。<br>         基本类型就是保存在栈内存中的简单数据段，而引用类型指的是那些保存在堆内存中的对象。<br><br>1、基本类型<br>         基本类型有Undefined、Null、Boolean、Number 和String。这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。<br><br>2、引用类型<br>          引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。如下图所示：栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。由于这种值的大小不固定，因此不能把它们保存到栈内存中。但内存地址大小的固定的，因此可以将内存地址保存在栈内存中。 这样，当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。<br><br><img src="./1502165642601.png" alt="Alt text"><br><br><br>其他语言中的内存分配类似。<br>     PS：当我们看到一个变量类型是已知的，就分配在栈里面，比如INT,Double等。其他未知的类型，比如自定义的类型，因为系统不知道需要多大，所以程序自己申请，这样就分配在堆里面。<br><img src="./1502165669503.png" alt="Alt text"><br><br><br><br>为什么会有栈内存和堆内存之分？<br>     通常与垃圾回收机制有关。为了使程序运行时占用的内存最小。<br>     当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；<br>     当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。<br><br><br><br><br><br>由于Javascript是松散型的，所以其变量只是在特定时间用于保存特定值的一个名字而已，并不存在某个变量必须保存某种类型的值的规则，变量的值以及其数据类型都可以在脚本的声明周期内改变<br>一、基本类型与引用类型<br>　　1.1 基本类型：保存在栈内存中的简单数据段，值保存在内存中的一个位置<br>　　1.2 引用类型：保存在堆内存中的对象，变量保存的仅仅是一个指针，这个指针指向内存中的另一个位置，该位置保存对象<br>　　　　1.2.1 5种基本数据类型：Undefined、Null、Boolean、Number、String在内存中分别占有固定大小的空间，保存在栈内存中<br>　　　　1.2.2 按值访问：对于保存基本数据类型的变量，我们操作的是它们实际保存的值<br>　　　　1.2.3 引用类型的值由于大小不固定，因此保存在堆内存中，但存放引用类型值的堆内存的内存地址大小是固定的，因此我们将这个地址保存在栈内存中，当操作引用类型的值时，先到栈内存　　　　　　　　读取该引用类型值的堆内存地址，然后在找到保存在堆内存中的引用类型的值<br>　　　　1.2.4 按引用访问：因为我们操作的不是实际的值，而是被这个值所引用的对象<br>　　　　1.2.5 保存在栈内存中的每个值分别占据固定大小的空间，因此可以按照顺序来访问<br>　　　　　　<br><img src="./1502165692819.png" alt="Alt text"><br><br>　　1.3 动态属性：只能给引用类型值动态的添加属性<br>　　1.4 复制变量值：针对基本数据类型值的复制，会在栈中创建一个新值，然后把该值复制到为新变量分配的位置上<br>　　　　针对引用类型值时，复制的只是一个指针，复制操作结束后，两个变量实际上将引用同一个对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> num2=num1;</span><br><span class="line">num1=<span class="number">6</span>;</span><br><span class="line">alert(num2);<span class="comment">//5</span></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="keyword">var</span> obj1=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj2=obj1;</span><br><span class="line">obj1.name=<span class="string">"Jim"</span>;</span><br><span class="line">alert(obj2.name);<span class="comment">//"Jim"</span></span><br></pre></td></tr></table></figure><br><br><img src="./1502165707301.png" alt="Alt text"><br><br><br><br>　<font color="red" size="5">1.5 传递参数：所有的参数传递全部是按值传递，虽然访问变量的时候有按值和按引用两种方式，但是参数传递只能按值传递。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，这个变量的变化不会反映在函数外面<br>　</font><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)&amp;#123;传递的时候应该是<span class="title">obj</span>=<span class="title">p</span>，<span class="title">obj</span>此时存的是<span class="title">p</span>中的地址</span></span><br><span class="line"><span class="function">    <span class="title">obj</span>.<span class="title">name</span>="<span class="title">Jim</span>";  --&gt;把<span class="title">obj</span>指向的对象添加一个键值对<span class="title">name</span>：“<span class="title">jim</span>”；</span></span><br><span class="line"><span class="function">    <span class="title">obj</span>=<span class="title">new</span> <span class="title">Object</span>(<span class="params"></span>);--&gt;<span class="title">new</span> <span class="title">Object</span>（）创建一个新的对象把新对象的地址赋给<span class="title">obj</span>，此时<span class="title">obj</span>的地址不再是<span class="title">p</span>的地址</span></span><br><span class="line"><span class="function">    <span class="title">obj</span>.<span class="title">name</span>="<span class="title">Greg</span>";  --&gt;给新的对象内存中添加一个键值对<span class="title">name</span>：<span class="title">Greg</span>；                             </span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">p</span>=<span class="title">new</span> <span class="title">Object</span>(<span class="params"></span>);//<span class="title">p</span>存储一个地址<span class="title">xxxfff000</span></span></span><br><span class="line"><span class="function"><span class="title">setName</span>(<span class="params">p</span>);</span></span><br><span class="line"><span class="function"><span class="title">alert</span>(<span class="params">p.name</span>);//"<span class="title">Jim</span>"</span></span><br><span class="line"><span class="function">//如果是按引用传递的话，那么<span class="title">p</span>就会被自动修改为指向其<span class="title">name</span>属性为”<span class="title">Greg</span>“的新对象，但是由下图分析可知，参数传递是按值传递</span></span><br></pre></td></tr></table></figure><br><br><img src="./1502165783773.png" alt="Alt text"><br><br>　　1.6 检测类型：typeof操作符是确定一个变量是字符串、数值、布尔、还是undefined，以及object的最佳工具，但是对于一个对象或者null，却只能返回”object”,因此在检测引用类型值的时候，引入了instanceof操作符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Name</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">p</span>=<span class="title">new</span> <span class="title">Name</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function"><span class="title">alert</span>(<span class="params">p instanceof Name</span>);//<span class="title">true</span></span></span><br></pre></td></tr></table></figure><br><br>二、执行环境和作用域<br>　　2.1 执行环境定义了变量和函数有权访问的其他数据，每个执行环境都有一个变量对象，环境中的所有变量和函数都保存在这个对象中，我们编写的代码无法访问这个对象<br>　　2.2 全局执行环境：最外围的一个执行环境，在web浏览器中，全局执行环境是window对象，因此全局变量和函数都作为window对象的属性和方法创建的<br>　　2.3 当某个执行环境的所有代码执行完毕后，该环境会被销毁，保存在其中的变量和函数也会被销毁<br>　　2.4 全局执行环境的销毁是在关闭网页或者浏览器时<br>　　2.5 每个函数都有自己的执行环境，当执行到某个函数时，会把控制权交给该函数，直到该函数执行完毕后，再把控制权交给之前的环境<br>　　2.6 当代码在一个环境(例如一个函数)中执行时，会创建变量对象的作用域链<br>　　2.7 作用域链的作用是保证对执行环境中的变量和函数的有序访问<br>　　2.8 作用域链的前端始终是当前代码的执行环境的变量对象<br> 　　2.9 如果执行环境是函数，那么变量对象是活动对象，初始只包含一个变量arguments对象，外层是包含该环境的环境，外层的外层是包含该环境的环境的环境，一直延伸到全局执行环境<br>　　2.10 全局执行环境始终是作用域链的最后一个对象<br>　　2.11 在搜索某个标识符(如变量名，函数名等)时，会沿着作用域链一级一级的搜索，直到找到，搜索停止，这也就达到了2.7中提到的作用域链的作用(保证对执行环境中的变量和函数的有序访问)<br><br><br><img src="./1502165807040.png" alt="Alt text"><br><br>　　2.12 内部环境可以通过作用域链一级一级访问都所有外部的变量以及函数，包括最外层的全局执行环境，但是外部环境却不能访问内部环境的变量和函数，作用域链只能从下向上搜索，不能从上向下搜索<br>　　2.13 例如swap函数可以访问全局变量color，但是全局变量window却不能访问到another或者temp<br>　　2.14 延长作用域链的方式：第一try-catch语句中的catch块，第二with语句，这两个语句都会在作用域链的前端添加一个变量对象，对于with语句来说，其变量对象中包含着为指定对象的所有属性和方法所作的变量声明。对于catch语句来时，其变量对象中包含的是被抛出的错误对象的声明，这些变量对象是只读的<br>　　2.15 浏览器的兼容性问题1注意IE与标准在try-catch语句延长作用域链的不同之处：即使在catch块的外部也可以访问到错误对象<br>　　2.16 js没有块级作用域的概念，所谓块级作用域就是由花括号封闭的代码块都有自己的作用域，但是js中使用var声明的变量，会被自动添加到距离最近的可用的执行环境中，未使用var声明被初始化的变量，会被自动添加到全局环境，其作用范围跟花括号没有关系<br>　　2.17 查询标识符时也会根据作用域链，从下向上一级一级进行搜索，搜索到后，就停止，因此，如果局部环境存在同名的标识符，就不会使用父环境中的标识符<br>三、垃圾收集机制<br>　　3.1 js具有自动垃圾收集机制，垃圾收集器会按照固定的时间间隔周期性地执行这一操作，两种方式：标记清除和引用计数<br>　　3.2 标记清除：js中最常用的垃圾收集方式，当执行流进入到相应的环境(即当执行流调用某个函数)时，该函数中声明了某个变量，那么这个变量就被标记为“进入环境”，从逻辑上讲，永远不能释放进入环境的变量的内存，当变量离开环境时，则被标记为“离开环境”。可利用翻转某个特殊的位来记录<br>　　3.3 引用计数：跟踪记录每个值被引用的次数，将一个引用类型的值赋值给一个变量，那么这个引用类型的值的引用次数就加1，相反，如果这个变量被赋值了其他值，这个引用类型的值的引用次数就减1，当引用次数为0时，就说明没有办法再访问这个引用类型的值了，那么她所占的内存空间会被垃圾回收器给回收<br>　　3.4 循环引用：如果对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的指针，就形成了循环引用，它们的引用次数永远不会为0，为了避免循环引用问题，最好是在不使用它们的时候，手工断开它们之间的连接<br>　　3.5 内存限制问题：js中分配给web浏览器的可用内存数量通常比分配给桌面应用程序的少，原因是为了防止运行js的网页耗尽全部内存而导致系统崩溃<br>　　3.6 解除引用：由于内存的限制，所以我们要优化内存占用，最佳策略就是执行代码只保存必要的数据，一旦数据不再用，最好通过将其值设置为null来释放对其的引用，这种方法称为解除引用<br>　　3.7 解除引用的适用范围：解除引用适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时自动被解除引用<br>　　3.8 对解除引用需要声明的一点：解除引用并不代表收回该值所占的内存，解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其收回<br><br><br><br><br>   栈内存和堆内存实例：<br><br>js中如果创建两个个对象p1,p2，使用p1为p2赋值会怎样？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"> </span><br><span class="line">p1.name = ‘zhangsan’;</span><br><span class="line"> </span><br><span class="line">p1.age = <span class="number">30</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> p2 = p1;</span><br></pre></td></tr></table></figure><br><br>这时，p1和p2会指向同一内存<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line"><span class="function">   &amp;#125;</span></span><br><span class="line"><span class="function">       <span class="title">var</span> <span class="title">p1</span> = <span class="title">new</span> <span class="title">person</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function">       <span class="title">p1</span>.<span class="title">name</span>= '<span class="title">zhangshan</span>';</span></span><br><span class="line"><span class="function">       </span></span><br><span class="line"><span class="function">       <span class="title">var</span> <span class="title">p2</span>= <span class="title">p1</span>;//对象之间赋值，现在<span class="title">p1</span> 和 <span class="title">p2</span>指向的是同一个内存空间</span></span><br><span class="line"><span class="function">   　　  //  <span class="title">alert</span>(<span class="params">p2.name</span>);</span></span><br><span class="line"><span class="function">　　　　<span class="title">var</span> <span class="title">p2</span> = '<span class="title">apple</span>';　//将<span class="title">p2</span>的值发生改变会影响<span class="title">p1</span>的值　</span></span><br><span class="line"><span class="function">　　　　//  <span class="title">alert</span>(<span class="params">p1.name</span>);</span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">   <span class="title">p2</span> = <span class="title">null</span> ;//这里是指将<span class="title">p2</span>的栈内存清除了，但是<span class="title">p2</span>指向的堆内存还是存在！</span></span><br><span class="line"><span class="function">//   <span class="title">alert</span>(<span class="params">p2.name</span>);</span></span><br><span class="line"><span class="function">   <span class="title">alert</span>(<span class="params">p1.name</span>);//所以这里可以输出结果！</span></span><br></pre></td></tr></table></figure><br><br><br><br>栈（操作系统）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈<br><br>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放<br><br>堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。<br><br>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些<br><br>堆（数据结构）：堆可以被看成是一棵树，如：堆排序<br><br>栈（数据结构）：一种后进先出的的数据结构<br><br><br>堆和栈的区别可以用如下的比喻来看出：<br>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。<br>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。<br><br><br><br><br>=====================================================================================<br><br><br>####<strong>关于阻止a标签的默认行为</strong><br><br>&gt;以下简单总结以下a标签阻止默认行为的几种简单方法，希望可以对有需要的朋友有些帮助，<br>(1)   <a href="javascript:void(0);" onclick="myjs( )" target="_blank" rel="noopener">  Click Me  </a><br>onclick方法负责执行js函数，而void是一个操作符，void(0)返回undefined，地址不发生跳转。<br><a href="javascript:;" target="_blank" rel="noopener">  Click Me  </a><br>和void(0)一样，都返回”undefined”<br><br>&gt;(2) <a href="#">  Click Me   </a><br>是网上很常见的代码，#是标签内置的一个方法，用这种方法点击后网页后返回到页面的最顶端所以又有了“##”“#!”等,尽管解决了返回顶部的问题但仍存在其他缺陷<br><br>&gt;(3)事件处理函数的工作机制中，在给某元素添加事件处理函数后，一旦事件发生，相应JavaScript代码就会执行，所调用的JavaScript代码的返回值被传递给事件处理函数。当我们给a标签添加onclick事件处理函数并点击a触发其后，<br>如果相应JavaScript代码返回true，onclick事件处理函数就会认为这个链接呗点击了，同样的若返回false即会认为链接<br>未被点击<br><a href="http://www.baidu.com" onclick=" myjs(); return false; " target="_blank" rel="noopener">   Click Me   </a><br><a href="http://www.baidu.com" onclick=" return false; " target="_blank" rel="noopener">  Click Me  </a><br>当点击a标签时，JavaScript代码返回值为false，故此链接默认行为未被触发。<br><br>&gt;(4)preventDefault()阻止事件的默认行为但不支持IE，所以在IE中使用returnValue阻止事件默认行为<br><a href="http://www.baidu.com" id="test" target="_blank" rel="noopener">  Click Me  </a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopDefault</span>(<span class="params"> e </span>)</span></span><br><span class="line"><span class="function">&amp;#123; </span></span><br><span class="line"><span class="function">   <span class="title">if</span> (<span class="params"> e &amp;&amp; e.preventDefault </span>) </span></span><br><span class="line"><span class="function">      <span class="title">e</span>.<span class="title">preventDefault</span>(<span class="params"></span>); </span></span><br><span class="line"><span class="function">     <span class="title">else</span> </span></span><br><span class="line"><span class="function">        <span class="title">window</span>.<span class="title">event</span>.<span class="title">returnValue</span> = <span class="title">false</span>;  </span></span><br><span class="line"><span class="function">&amp;#125; </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">test</span>.<span class="title">onclick</span> = <span class="title">function</span>(<span class="params">e</span>) </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&amp;#123; </span></span><br><span class="line"><span class="function">     <span class="title">stopDefault</span>(<span class="params">e</span>); </span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br></pre></td></tr></table></figure><br><br>================================================================================<br><br>####<strong>PS：innerText和innerHTML</strong><br> document 对象中有innerHTML和innerText 两个属性， 这两个属性都是获取document对象的文本内容的，这两个属性间有哪些区别呢？通过几个例子来看一下。<br><br>示例1<br>  1. <html><br>  2.     <head><title>innerHTML</title></head><br>  3.     <body><br>  4.         <p id="p1">hello world </p><br>  5.         <script><br>  6.             var content = document.getElementById(“p1”);<br>  7.             alert(content.innerHTML);<br>  8.             alert(content.innerText)<br>  9.         </script><br>  10.     </body><br>  11. </html><br>通过IE浏览器打开，弹出内容为 “hello world” 和 “hello world”<br>通过 Firefox 浏览器打开，弹出内容为 “hello world” 和 “undefined”<br>通过 chrome 浏览器打开，弹出内容为 “hello world” 和 “hello world”<br><br>示例2<br><br>   <html><br>   <head><title>innerHTML</title></head><br>    <body><br>       <div id="d1"><p id="p1">hello world </p></div><br>         <script><br>           var content = document.getElementById(“d1”);<br>          alert(content.innerHTML);<br>      alert(content.innerText)<br>        </script><br>     </body><br>  </html><br>通过IE浏览器打开，弹出内容为 <p id="p1">hello world </p> 和 hello world<br>通过 Firefox 浏览器打开，弹出内容为 <p id="p1">hello world </p> 和 undefined<br>通过 chrome 浏览器打开，弹出内容为 <p id="p1">hello world </p> 和 hello world<br><br><br>通过上面两个示例，可以看出：<br>innerHTML指的是从对象的起始位置到终止位置的全部内容,包括Html标签。<br>innerText   指的是从起始位置到终止位置的内容,但它去除Html标签。<br>同时，innerHTML 是所有浏览器都支持的，innerText 是IE浏览器和chrome 浏览器支持的，Firefox浏览器不支持。其实，innerHTML 是W3C 组织规定的属性；而innerText 属性是IE浏览器自己的属性，不过后来的浏览器部分实现这个属性罢了。<br><br>outerHTML<br><br>说到innerHTML，顺便说一下跟innerHTML相对的outerHTML属性。<br><br>继续看上面的代码，将alert(content.innerText) 修改为 alert(content.outerHTML)<br><br> 通过浏览器可以看到弹出框为<p id="p1">hello world </p><br>和 <divid="d1"><p id="p1">hello world</p><br><br>outerHTML指的是除了包含innerHTML的全部内容外, 还包含对象标签本身。<br><br><br>总结说明<br><br>　　innerHTML是符合W3C标准的属性，而innerText只适用于IE浏览器（现在也适应chrome浏览器），因此，尽可能地去使用 innerHTML，而少用innerText，如果要输出不含HTML标签的内容，可以使用innerHTML取得包含HTML标签的内容后，再用正则表达式去除HTML标签，下面是一个简单的符合W3C标准的示例：<br><br><br><br>弹出的为去掉了html标签之后的内容，这是个在所有浏览器均可使用的方法。<br><br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> &lt;html&gt;  </span><br><span class="line"><span class="number">2.</span>     &lt;head&gt;&lt;title&gt;innerHTML&lt;/title&gt;&lt;/head&gt;  </span><br><span class="line"><span class="number">3.</span>     &lt;body&gt;  </span><br><span class="line"><span class="number">4.</span>         &lt;div id=<span class="string">"d1"</span>&gt;&lt;p id="p1"&gt;hello world &lt;/p&gt;&lt;/div&gt;  </span><br><span class="line"><span class="number">5.</span>         &lt;script&gt;  </span><br><span class="line"><span class="number">6.</span>             <span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);  </span><br><span class="line"><span class="number">7.</span>             alert(content.innerHTML.replace(<span class="regexp">/&amp; lt;.+?&gt;/gim</span>,<span class="string">''</span>));  </span><br><span class="line"><span class="number">8.</span>         &lt;<span class="regexp">/script&gt;  </span></span><br><span class="line"><span class="regexp">9.     &lt;/</span>body&gt;  </span><br><span class="line"><span class="number">10.</span> &lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><br><br>innerHTML和innerText的区别：<br>1innerHTML插入内容的时候，浏览器会把插入内容中的HTML标签字符最后识别为正常的标签，而innerText不管写的是什么，最后浏览器都会识别为普通的文本。<br><br><br><br><br><br><br>============================================================================<br><br>####<strong>PS:关于函数的低耦合和高内聚</strong><br><br><br>   起因：模块独立性指每个模块只完成系统要求的独立子功能，并且与其他模块的联系最少且接口简单，两个定性的度量标准――耦合性和内聚性。<br><br>    耦合性也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。<br>    耦合性分类(低――高): 无直接耦合;数据耦合;标记耦合;控制耦合;公共耦合;内容耦合;<br>1 无直接耦合:<br>2 数据耦合: 指两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言的值传递;<br>3 标记耦合: 指两个模块之间传递的是数据结构，如高级语言中的数组名、记录名、文件名等这些名字即标记，其实传递的是这个数据结构的地址;<br>4 控制耦合: 指一个模块调用另一个模块时，传递的是控制变量（如开关、标志等），被调模块通过该控制变量的值有选择地执行块内某一功能;<br>5 公共耦合: 指通过一个公共数据环境相互作用的那些模块间的耦合。公共耦合的复杂程序随耦合模块的个数增加而增加。<br>6 内容耦合: 这是最高程度的耦合，也是最差的耦合。当一个模块直接使用另一个模块的内部数据，或通过非正常入口而转入另一个模块内部。<br><br>    内聚性又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。<br>    内聚性匪类(低――高): 偶然内聚;逻辑内聚;时间内聚;通信内聚;顺序内聚;功能内聚;<br>1 偶然内聚: 指一个模块内的各处理元素之间没有任何联系。<br>2 逻辑内聚: 指模块内执行几个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。<br>3 时间内聚: 把需要同时执行的动作组合在一起形成的模块为时间内聚模块。<br>4 通信内聚: 指模块内所有处理元素都在同一个数据结构上操作（有时称之为信息内聚），或者指各处理使用相同的输入数据或者产生相同的输出数据。<br>5 顺序内聚: 指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素输出就是下一功能元素的输入。<br>6 功能内聚: 这是最强的内聚，指模块内所有元素共同完成一个功能，缺一不可。与其他模块的耦合是最弱的。<br><br>    耦合性与内聚性是模块独立性的两个定性标准，将软件系统划分模块时，尽量做到高内聚低耦合，提高模块的独立性，为设计高质量的软件结构奠定基础。<br><br>    有个例子很容易明白：一个程序有50个函数，这个程序执行得非常好；然而一旦你修改其中一个函数，其他49个函数都需要做修改，这就是高耦合的后果。<br>一旦你理解了它，你编写概要设计的时候设计类或者模块自然会考虑到“高内聚，低耦合”。<br><br><br>=====================================================================================<br><br>####<strong>PS：使用JS获取当前元素的index值</strong><br><br><br><br>在之前面试的时候，笔记的环节总是碰到用原生js弹出当前点击li的indx值，今天没事就写一下，留作记忆！<br>下面是html机构，为了省事我就不加id class了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br>接下来就是js部分了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list =<span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line">for(var i=0;i&lt;list.length;i++)&amp;#123;</span><br><span class="line">	list[i].index=i;</span><br><span class="line">	list[i].onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function">		<span class="title">alert</span>(<span class="params">this.index+<span class="number">1</span></span>);                  //加不加1随你了！</span></span><br><span class="line"><span class="function">	&amp;#125; </span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br></pre></td></tr></table></figure><br><br>如果你把js代码放到了头部，一定要记得加window.onload=function()&#123;&#125;<br><br>放到头部，不加这段代码的话会点击没有反应，或者直接报错：<br>Uncaught TypeError: Cannot set property ‘onclick’ of null;<br>后来在stackoverflow 找到了原因。要是对DOM操作的话，要先加载完全。扯的有点远了啊！<br>接下换一个写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list =<span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line">				for(var i=0;i&lt;list.length;i++)&amp;#123;</span><br><span class="line">					list[i].onclick =	(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)&amp;#123;</span></span><br><span class="line"><span class="function">						<span class="title">return</span> <span class="title">function</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line"><span class="function">							<span class="title">alert</span>(<span class="params">n</span>);</span></span><br><span class="line"><span class="function">						&amp;#125;</span></span><br><span class="line"><span class="function">					&amp;#125;)(<span class="params">i</span>)</span></span><br><span class="line"><span class="function">	  		&amp;#125;</span></span><br><span class="line"><span class="function">	  	&amp;#125;</span></span><br></pre></td></tr></table></figure><br><br>最后附上完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">	&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">		li&amp;#123;</span><br><span class="line">			background-color: red;</span><br><span class="line">		&amp;#125;</span><br><span class="line">	&lt;/style&gt;</span><br><span class="line">	&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">		window.onload=function()&amp;#123;</span><br><span class="line">			</span><br><span class="line">			var list =document.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">				for(var i=0;i&lt;list.length;i++)&amp;#123;</span><br><span class="line">					list[i].onclick =	(function(n)&amp;#123;</span><br><span class="line">						return function()&amp;#123;</span><br><span class="line">							alert(n);</span><br><span class="line">						&amp;#125;</span><br><span class="line">					&amp;#125;)(i)</span><br><span class="line">	  		&amp;#125;</span><br><span class="line">	  	&amp;#125;</span><br><span class="line">  	&amp;#125;</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;ul&gt;</span><br><span class="line">		&lt;li&gt;1&lt;/li&gt;</span><br><span class="line">		&lt;li&gt;2&lt;/li&gt;</span><br><span class="line">		&lt;li&gt;3&lt;/li&gt;</span><br><span class="line">		&lt;li&gt;4&lt;/li&gt;</span><br><span class="line">		&lt;li&gt;5&lt;/li&gt;</span><br><span class="line">	&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br><br>=====================================================================================<br><br>####<strong>alert输出对象的问题</strong><br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&amp;#123;name:'xxx'&amp;#125;)；//-&gt; '[Object,Object]' 两个大写Object</span><br></pre></td></tr></table></figure><br><br><img src="./1502166964946.png" alt="Alt text"><br><br><br><br><br><br><br><br><br><br>#### <strong>console的强大</strong><br><br><br>&gt;写在前面<br>大家都有用过各种类型的浏览器，每种浏览器都有自己的特色，本人拙见，在我用过的浏览器当中，我是最喜欢Chrome的，因为它对于调试脚本及前端设计调试都有它比其它浏览器有过之而无不及的地方。可能大家对console.log会有一定的了解，心里难免会想调试的时候用alert不就行了，干嘛还要用console.log这么一长串的字符串来替代alert输出信息呢，下面我就介绍一些调试的入门技巧，让你爱上console.log<br>先的简单介绍一下chrome的控制台，打开chrome浏览器，按f12就可以轻松的打开控制台<br><br><img src="./1502172057370.png" alt="Alt text"><br><br>&gt; 大家可以看到控制台里面有一首诗还有其它信息，如果想清空控制台，可以点击左上角那个<br> <img src="./1502172127554.png" alt="Alt text"><br><br>&gt;来清空，当然也可以通过在控制台输入console.clear()来实现清空控制台信息。如下图所示<br>&gt;<img src="./1502172156876.png" alt="Alt text"><br>现在假设一个场景，如果一个数组里面有成百上千的元素，但是你想知道每个元素具体的值，这时候想想如果你用alert那将是多惨的一件事情，因为alert阻断线程运行，你不点击alert框的确定按钮下一个alert就不会出现。<br>&gt; 下面我们用console.log来替换，感受一下它的魅力。<br><img src="./1502172189283.png" alt="Alt text"><br><br><br>&gt;看了上面这张图，是不是认识到log的强大之处了，下面我们来看看console里面具体提供了哪些方法可以供我们平时调试时使用。<br>&gt;<img src="./1502172243456.png" alt="Alt text"><br><br><br>&gt;1、先说一下源码定位<br>    大家打开测试网页   看到页面右下方有一个推荐的图标吗？右击推荐图标，选择审查元素，打开谷歌控制台，如下图所示<br><img src="./1502172284025.png" alt="Alt text"><br><br>&gt;我们现在想知道votePost方法到底在哪？跟着我这样做，在Console面板里面输入votePost然后回车<br><img src="./1502172313643.png" alt="Alt text"><br>&gt;直接点击上图标红的链接，控制台将定位到Sources面板中，展示如下图所示<br>&gt;<img src="./1502172335245.png" alt="Alt text"><br><br>&gt;大家看了上面这个图片之后估计头都要晕了吧，这么多js都整在一行，让人怎么看呀，不用担心，按下图操作即可（也就是点击中间面板左下方的Pretty print就行了）<br>&gt;<img src="./1502172365940.png" alt="Alt text"><br>&gt;这时我们再回到Console面板时会惊奇的发现原来的链接后面的1现在变成91了（其实这里的数字1或者91就是代表votePost方法在源码中的行号 ）现在看出Pretty print按钮的强大之处了吧<br>知道了怎么样查看某一个按钮的源码，那接下来的工作便是调试了，调试第一步需要做的便是设置断点，其实设置断点很简单，点击一下上图所示的92即可，这时你会发现92行号旁边会多了一个图标，这里解释一下为什么不在91处设置断点，你可以试下，事实上根本就没法在91处上设置断点，因为它是函数的定义处，所以没法在此设置断点。<br><img src="./1502172407251.png" alt="Alt text"><br><br>&gt;设置好了断点后，你就会在右边Breakpoints方框里看到刚刚设置的断点。<br>我们先来介绍一下用到的调试快捷键吧（事实上我们也可以不用下表所示的快捷键，直接点击上图所示右侧栏最上层的一排按钮来进行调试，具体用哪个按钮，把鼠标放到按钮上方一会就会显示它相应的提示）<br><img src="./1502172424500.png" alt="Alt text"><br><br>&gt;其中值得一提的是，当我们点击“推荐”按钮进行调试的时候会发现，不管我们是按的F10进行调试还是按F11进行逐步调试，都没法进行$.ajax函数内部，即使我们在函数内部设置了断点也没有办法进入，这里按F8才是真正起效果的，不信你试试。<br>当我们在调试的时候，右侧Scope Variables里面会显示当前作用域以及他的父级作用域，以及闭包。你不仅能在右侧 Scope Variables(变量作用域) 一栏处看到当前变量，而且还能把鼠标直接移到任意变量上，就可以查看该变量的值。<br>用图说话（哈哈）<br><img src="./1502172441322.png" alt="Alt text"><br><br><br>&gt;刚刚我们介绍的只是在html里面能够看得到它绑定了onclick事件，这样我们就找到它绑定的js函数，如果它是在jQuery页面加载完成函数里面绑定的，这时候我们怎么知道它绑定的是哪个js函数呢，如果我们不知道绑定的js函数就更加不用说调试进去了<br>下面介绍一下如何查看，还是以刚刚那个测试网页为例子吧，但是这次我们来看“提交评论”作说明吧，<br>右击“提交评论”–&gt;审核元素，我们可以清楚的看到在这个按钮上未绑定任何事件。在Console面板内输入如下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lookEvents</span> (<span class="params">elem</span>) &amp;#123;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">$</span>.<span class="title">data</span> ? <span class="title">$</span>.<span class="title">data</span>(<span class="params"> elem, <span class="string">"events"</span>, undefined, true </span>) : <span class="title">$</span>.<span class="title">_data</span>(<span class="params"> elem, <span class="string">"events"</span> </span>);</span></span><br><span class="line"><span class="function">&amp;#125;</span></span><br><span class="line">var event = lookEvents($("#btn_comment_submit")[0]); // 获取绑定的事件</span><br></pre></td></tr></table></figure><br><br>如下图所示：<br><img src="./1502172491156.png" alt="Alt text"><br><br>&gt;按照上述介绍的方法定位到具体的blog-common.js里面，找到postComment  然后一层层的找到具体的代码，再设置断点就好了。<br>最后介绍一下一个神器，很好用的debugger<br>如果你自己写的代码，你执行的时候想让它在某一处停下来，只要写上的debugger就好了，不信你试试！哈哈<br>回到顶部<br><font color="red"><strong>谷歌控制台Elements面板</strong></font><br>要想打开谷歌控制台，有两种方式<br>  1. ctrl+shift+i<br>  2. f12<br>大家知道Elements面板最大的功能就是操作属性和修改html。这里我再说一些大家可能不太熟悉的特性，<br>  ● 拖拽节点, 调整顺序<br>  ● 拖拽节点到编辑器<br>  ● ctrl + z 撤销修改<br>这些功能是我觉得最有意思的，你们可以试试哦。<br>下面来具体说说几个复杂点的功能<br>回到顶部<br>查看元素上绑定的事情<br>  ● 默认会列出 All Nodes, 这些包括代理绑定在该节点的父/祖父节点上的事件, 因为在在冒泡或捕获阶段会经过该节点<br>  ● Selected Node Only 只会列出当前节点上绑定的事件<br>  ● 每个事件会有对应的几个属性 handler, isAtribute, lineNumber, listenerBody, sourceName, type, useCapture<br><br>  ● handler是处理函数, 右键可以看到这个函数定义的位置, 一般 js 库绑定事件会包一层, 所以这里很难找到对应handler<br>  ● isAtribute 表明事件是否通过 html 属性(类似onClick)形式绑定的<br>  ● useCapture 是 addEventListener 的第三个参数, 说明事件是以 冒泡 还是 捕获 顺序执行<br><br><img src="./1502172555574.png" alt="Alt text"><br><br><br><font color="red"><em>*样式操作</em></font></divid="d1"></em></em></length;i++)类似这样的循环时的问题，因为javascript没有代码块级别的变量，所以这里的i的访问权限其实是所在的方法。有x的书上会建议程序员把这样的变量声明放到一处去，但是从直观性上说，在大部分情况下都不够合理。></font><br>可以通过 ctrl + z 取消<br><br><img src="./1502172624759.png" alt="Alt text"><br><br><br>&gt;总况<br>目前控制台方法和属性有：<br>[“$$”, “$x”, “dir”, “dirxml”, “keys”, “values”, “profile”, “profileEnd”, “monitorEvents”, “unmonitorEvents”, “inspect”, “copy”, “clear”, “getEventListeners”, “undebug”, “monitor”, “unmonitor”, “table”, “$0”, “$1”, “$2”, “$3”, “$4”, “$“]<br>下面我们来一一介绍一下各个方法主要的用途。<br>一般情况下我们用来输入信息的方法主要是用到如下四个<br><br>console.log<br><br>用于输出普通信息<br><br><br>console.info<br><br>用于输出提示性信息<br><br>console.error<br>用于输出错误信息<br><br>console.warn<br>用于输出警示信息<br><br>console.debug<br>用于输出调试信息<br>用图来说话<br><img src="./1502172696626.png" alt="Alt text"><br><br><br>console对象的上面5种方法，都可以使用printf风格的占位符。不过，占位符的种类比较少，只支持字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）四种。<br><br><img src="./1502172707979.png" alt="Alt text"><br><br>&gt;  console.log(“%d年%d月%d日”,2011,3,26);<br>　 console.log(“圆周率是%f”,3.1415926);<br><img src="./1502172724060.png" alt="Alt text"><br><br><br>&gt;%o占位符，可以用来查看一个对象内部情况<br>var dog = &#123;&#125;;<br>dog.name = “大毛”;<br>dog.color = “黄色”;<br>console.log(“%o”, dog);<br><br><img src="./1502172744794.png" alt="Alt text"><br><br><br>&gt;下面重点说一下console.log的一些技巧<br><font color="purple"><strong>1、改变输出文字的样式</strong></font>

<p><img src="./1502172762173.png" alt="Alt text"></p>
<blockquote>
<p>console.log(“%c3D Text”,” text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em”);</p>
<p>console.log(‘%cRainbow Text ‘, ‘background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;’);</p>
</blockquote>
<p>输出的结果如下图所示：</p>
<p><img src="./1502172786415.png" alt="Alt text"></p>
<font color="purple"><strong>2、利用控制台输出图片</strong></font>

<p><img src="./1502172864203.png" alt="Alt text"></p>
<font color="purple"><strong>2、指定输出文字的样式</strong></font>

<p><img src="./1502172887901.png" alt="Alt text"></p>
<p>console.dirxml<br>用来显示网页的某个节点（node）所包含的html/xml代码</p>
<font color="purple"><strong>3、console.dirxml</strong></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;table id=&quot;mytable&quot;&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;A&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;A&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;A&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;bbb&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;aaa&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;ccc&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;111&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;333&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;222&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function () &amp;#123;</span><br><span class="line">        var mytable = document.getElementById(&apos;mytable&apos;);</span><br><span class="line">        console.dirxml(mytable);</span><br><span class="line">    &amp;#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br><br><img src="./1502172957318.png" alt="Alt text"><br><br><font color="purple"><strong>4、console.group和console.groupEnd</strong></font>

<blockquote>
<p>输出一组信息的开头和输出结束一组输出信息<br>看你需求选择不同的输出方法来使用，如果上述四个方法再配合group和groupEnd方法来一起使用就可以输入各种各样的不同形式的输出信息。</p>
</blockquote>
<p><img src="./1502173012717.png" alt="Alt text"></p>
<font color="purple"><strong>4、console.assert</strong></font>

<p>对输入的表达式进行断言，只有表达式为false时，才输出相应的信息到控制台</p>
<p><img src="./1502173055839.png" alt="Alt text"></p>
<font color="purple"><strong>5、console.count</strong></font>

<blockquote>
<p>（这个方法非常实用哦）当你想统计代码被执行的次数<br><img src="./1502173150296.png" alt="Alt text"></p>
</blockquote>
<font color="purple"><strong>6、console.dir</strong></font><br>&gt;(这个方法是我经常使用的 可不知道比for in方便了多少) 直接将该DOM结点以DOM树的结构进行输出，可以详细查对象的方法发展等等<br><br><br><img src="./1502173186549.png" alt="Alt text"><br><br><br><font color="purple"><strong>7、console.time和console.timeEnd</strong></font>

<blockquote>
<p>计时开始和计时结束（看了下面的图你瞬间就感受到它的厉害了）<br><img src="./1502173232556.png" alt="Alt text"></p>
</blockquote>
<font color="purple"><strong>8、console.profile和console.profileEnd</strong></font>

<blockquote>
<p>配合一起使用来查看CPU使用相关信息</p>
</blockquote>
<p><img src="./1502173278002.png" alt="Alt text"></p>
<blockquote>
<p>在Profiles面板里面查看就可以看到cpu相关使用信息<br><img src="./1502173301042.png" alt="Alt text"></p>
</blockquote>
<font color="purple"><strong>9、console.timeLine和console.timeLineEnd</strong></font>

<blockquote>
<p>配合一起记录一段时间轴</p>
</blockquote>
<font color="purple"><strong>10、console.trace</strong></font>

<blockquote>
<p>堆栈跟踪相关的调试<br>如果想查看具体API，可以上官方看看，具体地址为：<a href="https://developer.chrome.com/devtools/docs/console-api" target="_blank" rel="noopener">https://developer.chrome.com/devtools/docs/console-api</a><br>下面介绍一下控制台的一些快捷键</p>
</blockquote>
<font color="purple"><strong>11、方向键盘的上下键</strong></font><br>&gt;大家一用就知晓。比如用上键就相当于使用上次在控制台的输入符号<br><br><br><font color="purple"><strong>12、$_</strong></font>

<blockquote>
<p>命令返回最近一次表达式执行的结果，功能跟按向上的方向键再回车是一样的</p>
</blockquote>
<p><img src="./1502173448680.png" alt="Alt text"></p>
<p>上面的\$_需要领悟其奥义才能使用得当，而\$0~$4则代表了最近5个你选择过的DOM节点。<br>什么意思？在页面右击选择审查元素，然后在弹出来的DOM结点树上面随便点选，这些被点过的节点会被记录下来，而\$0会返回最近一次点选的DOM结点，以此类推，$1返回的是上上次点选的DOM节点，最多保存了5个，如果不够5个，则返回undefined。</p>
<blockquote>
<p>\$ // 简单理解就是 document.querySelector 而已。<br>$$ // 简单理解就是 document.querySelectorAll 而已。<br>$_ // 是上一个表达式的值<br>$0-$4 // 是最近5个Elements面板选中的DOM元素，待会会讲。<br>dir // 其实就是 console.dir<br>keys // 取对象的键名, 返回键名组成的数组<br>values // 去对象的值, 返回值组成的数组<br>看一下chrome控制台一个简单的操作，如何查看页面元素，看下图就知道了</p>
</blockquote>
<p><img src="./1502173745894.png" alt="Alt text"></p>
<font color="purple"><strong>13、Chrome 控制台中原生支持类jQuery的选择器</strong></font>

<blockquote>
<p>也就是说你可以用$加上熟悉的css选择器来选择DOM节点</p>
</blockquote>
<p><img src="./1502173787555.png" alt="Alt text"></p>
<font color="purple"><strong>14、copy</strong></font><br>&gt;通过此命令可以将在控制台获取到的内容复制到剪贴板(如果在elements面板中选中某个节点，也可以直接按ctrl+c执行复制操作)<br><br><img src="./1502173822819.png" alt="Alt text"><br><br><font color="purple"><strong>15、keys和values</strong></font>

<blockquote>
<p>前者返回传入对象所有属性名组成的数据，后者返回所有属性值组成的数组<br><img src="./1502173861020.png" alt="Alt text"></p>
</blockquote>
<font color="purple"><strong>14、console.table</strong></font>

<p><img src="./1502173882070.png" alt="Alt text"></p>
<p><font color="purple"><strong>14、monitor &amp; unmonitor</strong></font></p>
<blockquote>
<p>monitor(function)，它接收一个函数名作为参数，比如function a,每次a被执行了，都会在控制台输出一条信息，里面包含了函数的名称a及执行时所传入的参数。<br>而unmonitor(function)便是用来停止这一监听。<br><img src="./1502173938698.png" alt="Alt text"><br>看了这张图，应该明白了，也就是说在monitor和unmonitor中间的代码，执行的时候会在控制台输出一条信息，里面包含了函数的名称a及执行时所传入的参数。当解除监视（也就是执行unmonitor时）就不再在控制台输出信息了。</p>
</blockquote>
<h4 id="关于定时器清除"><a href="#关于定时器清除" class="headerlink" title="关于定时器清除"></a>关于定时器清除</h4><blockquote>
<p>许多人在清除的定时器的时候会把存储定时器个数的变量赋值为null<br>看代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let timer=setInterval(()=&gt;&amp;#123;&amp;#125;,1000);</span><br><span class="line">clearInterval(timer);</span><br><span class="line">timer=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>这样做有什么好处呢？<br>其实当我们执行clearInterval的时候 的确把定时器清掉了，如果我们在函数作用域中这样做那么浏览器会自动进行垃圾回收<br>但是如果timer是在全局下声明的，那么这时候短时间是不会被回收的，这时候我们手动把它设置为null ，会便于浏览器的垃圾回收。</p>
</blockquote>
</font>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/胡子课堂react小记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daima Hao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="好带马的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/胡子课堂react小记/" itemprop="url">胡子课堂react小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T17:06:07+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="react-事件监听"><a href="#react-事件监听" class="headerlink" title="react 事件监听"></a>react 事件监听</h4><blockquote>
<p>1.在react中绑定事件只需要调用react封装好的一系列on事件即可<br>2.react中的event的对象不是原生的，而是自己封装的，它帮助我们处理了一些细节问题所以我们不必考虑其兼容性，这个事件对象同样符合是符合W3C标准的<br>3.react中的事件只能绑给普通的html标签，像自定义组件类的标签不能绑定不会有效果<br>4.react 在调用方法的时候是按照函数名直接调用的而不是通过xx.xxx所以他的this指向是不明的，在class中均使用的use strict 模式所以this 是undefined或null，需要我们手动绑定。改变this的方法有三个，call，apply，bind，显然bind符合需求，此外我们还可以使用箭头函数来保证this的指向不会错乱；</p>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-组件的state和setState"><a href="#react-组件的state和setState" class="headerlink" title="react 组件的state和setState"></a>react 组件的state和setState</h4><blockquote>
<p>1.state<br>  state代表组件的状态对象，每个组件都可以有自己的状态，用来存储一些描述组件的信息</p>
<p>2.setState<br>   设置组件状态的方法，接受一个对象参数，这里只需要添加你想改变的状态即可，setState其实是利用了&#123;…state&#125;浅拷贝新建了一个对象，并且每次调用setState方法都会重新调用render方法渲染页面，此外setState是异步的设置状态的，这意味着你并不能在setState下面立即得到改变后的状态（这里react是把传入新的状态对象放到了一个更新队列里，稍后才会从队列里取出，合并到state中更新状态，从而触发render更新组件）<br>  当我们像立即获取setState的状态用于后续的操作时，显然是很困难的，对于这种依赖前一个状态的需求，我们可以使用setState的第二种使用方式，传入一个函数，这个函数返回一个处理过的状态对象，并且这个函数接受一个参数，这个参数表示上一次改变后的状态对象</p>
<p>3.setState的合并<br>  当你尝试调用多次setState去处理同一个状态值的时候 react只会处理一次触发一次render函数（在react内部会把javascript事件循环中的消息队列的同一个消息中的setState都进行合并后在进行渲染组件）所以当我们使用setState时候不需考虑多次渲染会带来的性能问题。</p>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-组件中的props"><a href="#react-组件中的props" class="headerlink" title="react 组件中的props"></a>react 组件中的props</h4><blockquote>
<ol>
<li>为了让组件更为可控，更能满足不同的需求，我们需要传入参数对象props<br>props里包含了你对这个组件的所有配置，组件内部通过this.props拿到这个配置，在使用一个组件的时候可以把参数放到标签的属性中，所有的属性都会作为props的一个键值，jsx的表达式可以在标签上使用，所以我们可以把任何数据类型作为组件的参数包括字符串，对象，数组，甚至是函数   </li>
<li>默认配置 defaultProps<br>react提供了一个默认配置参数对象来避免繁杂的逻辑判断（早知道有这个我就省了很多代码）这样我们就不需要判断配置属性了，当props没有传入的时候组件会直接使用默认配置<br>3.props的不可变   props一旦传入就不能改变，你不能改变一个组件被渲染时候的props，react希望一个组件在输入确定的props时，能够输出确定UI显示形态，如果在渲染过程中可以自由修改props，那么这个组件的表现就会变的不可预测，这样是很危险的，但是这并不意味着react中的props绝对不能修改（又一个编程无绝对的体现！），我们可以通过让上级组件重新渲染的方式来给组件传递新的props</li>
</ol>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-state和props-的总结比较"><a href="#react-state和props-的总结比较" class="headerlink" title="react state和props 的总结比较"></a>react state和props 的总结比较</h4><blockquote>
<p>1.state的主要作用于自身所在的组件，是可变的状态，但是只能被自身修改，外界组件不能访问和修改，state是一个自身的数据源，然后setState方法会修改state并触发组件的重新渲染</p>
<p>2.props的主要作用是让使用该组件的父组件传入配置参数来改变组件的显示形态的，props正好相反，传入的子组件内部无法控制也无法修改，除非外部组件自己更新props否则传入子组件内部的props永远不变</p>
<p>3.state和props有很多的联系，它们都可以决定组件的行为和显示形态，一个组件的state中的数据可以通过props传给子组件，一个子组件也可以用外部传入的props来改变自己的state，但是他们的职责很明确：state是让组件控制自己的状态，props是让外部对子组件进行配置，</p>
<p>4.原则上少用state 多用props，多写无状态组件，少写有状态的组件，因为前端中状态管理是一个复杂的问题，react 鼓励使用无状态组件，所以引入了函数组件，函数组件和类组件 大体类似，只是函数组件不接受state状态对象，只接受参数对象</p>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-渲染列表数据"><a href="#react-渲染列表数据" class="headerlink" title="react 渲染列表数据"></a>react 渲染列表数据</h4><blockquote>
<p>1.渲染存放JSX元素的数组。<br>   如果你往JSX表达式中放一个数组，react会帮你把里面的一个一个jsx元素罗列并渲染出来</p>
<p>2.在react 中我们经常使用map来渲染列表数据，利用map<br>  遍历整个数组然后返会一个我们需要格式的jsx元素实现对列表数据的迭代渲染，<br>  值得注意的是在迭代出的每一个列表元素都需要绑定一个唯一的key，来帮助react识别来避免react无法识别列表元素的位置改变而重新渲染整个列表，大大降低性能，<br>  有了key react就可以判断出来元素是否只是位置变化，从而只交换这两个元素而不会&gt;   去重新渲染，如果使用map方法的index 作为key，实际上是不保险的做法，因为实际&gt;   开发中你可能会改变数据的顺序，所以最普遍的做法是使用后台返回的id做唯一标识    </p>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-评论功能（一）"><a href="#react-评论功能（一）" class="headerlink" title="react  评论功能（一）"></a>react  评论功能（一）</h4><blockquote>
<ol>
<li>组件的划分，组件的划分并没有明确的规则，只要你觉得那部分组件需要复用，或者单个组件逻辑过于复杂为了实现简洁优雅的代码你都可以把他们提取成一个单独的组件</li>
</ol>
<p>2.我们写类组件的时候应该遵循一个准则就是首字母要大写</p>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-评论功能（二）"><a href="#react-评论功能（二）" class="headerlink" title="react  评论功能（二）"></a>react  评论功能（二）</h4><blockquote>
<p>1.处理用户输入，当我们在react 把input textarea等输入框的value值绑定到状态时，我们就无法再输入了，因为react 当state确定的时候 会让state管理所有的状态，值（state没有变化）不变的的时候，value就不会改变，怎么解决这个问题呢？我们可以给对应的标签绑定onChange事件当输入的时候触发事件调用setState方法改变state进而改变value值，实现能够输入</p>
<p>2.另外我们可以发现这次我们的两个主要逻辑组件是分开的，而且当我们使用input组件输入内容时，需要让另一个组件list显示这个内容，那么用于同级组件间的通信就显得很困难了，props和state显然无法满足需求，这时候我们观察可以发现父组件包含这两个子组件，也就是父组件可以承担桥梁的作用来做一个数据中转，我们可以在子组件中传入一个方法，这个方法接受一个参数用于存储用户输入的值，然后我们把这个可以设置到父组件上再传入到另一个组件实现组件间的通信，因为我们的函数通过props传递过去，所以子组件内接收到的只是这个函数的地址，所有子组件其实也是真实在操作父组件的函数，因为他们是同一个地址。</p>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-评论功能（三）"><a href="#react-评论功能（三）" class="headerlink" title="react  评论功能（三）"></a>react  评论功能（三）</h4><blockquote>
<p>1.在这里我们就通过给父组件设置公用的状态，来实现两个组件的通讯，由此我们可以发现react中 数据流向是固定的，总是从上到下，父到子，我们只有通过一些方法才能实现子组件来修改父组件的状态</p>
<ol>
<li>defaultProps是一个静态变量，为了防止第一次组件渲染时候，并没有执行组件的事件，所以需要传入的值还没有导致报错，如果没有传入就默认使用defaultProps</li>
</ol>
<p>3.这里我们直接修改了state而没有通过setState，这显然是不符合react 的期望的，这个原则是为了shouldCommpoentUpdate的优化和跟踪，这个目的在我们使用react-redux的时候就自然的达到了，所以我们很少去手动优化，这里这个原则就显得没有那么重要。</p>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-前端状态管理-状态提升"><a href="#react-前端状态管理-状态提升" class="headerlink" title="react  前端状态管理-状态提升"></a>react  前端状态管理-状态提升</h4><p><img src="https://huzidaha.github.io/static/assets/img/posts/85B8A2B7-288F-4FC2-A0AB-C4E153BB3854.png" alt=""></p>
<blockquote>
<p>1.我们可以发现，当我们有一个状态需要被多个同级组件使用或者影响的时候，我们再把组件放到某个组件内部显然是不合适的，这时候我们需要把组件放到他们的共同的父组件中，以便于以后每个子组件都可以使用这个状态，这种做法就叫做状态提升，但是我们也可以想到加入组件有好多层级，恰好又都需要某个状态，那么我们将陷入频繁的提升状态中和一级一级繁琐的传递状态中去，显然这样做是很不好的做法，所以我们在之后会使用redux这样的状态管理工具来帮助我们管理复杂的状态；</p>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-挂载阶段的组件生命周期（一）"><a href="#react-挂载阶段的组件生命周期（一）" class="headerlink" title="react 挂载阶段的组件生命周期（一）"></a>react 挂载阶段的组件生命周期（一）</h4><blockquote>
<ol>
<li><p>当我们调用ReactDOM.render（）方法传入我们的组件和根节点时，其实在内部react是先实例化这个类组件的一个实例，然后执行组件的render方法返回一个描述组件渲染状态的对象，再把这个对象通过&gt; &gt; &gt; createDOMFromObject创建成真正的DOM结构插入到根节点中；</p>
</li>
<li><p>react把组件渲染，然后构造DOM元素插入页面的过程就成为组件的挂载</p>
</li>
<li><p>react组件的生命周期函数有</p>
<ul>
<li>componentWillMount 组件即将挂载</li>
<li>componentDidMount 组件已经挂载完成</li>
<li>componentWillUnMount 组件即将卸载</li>
</ul>
</li>
<li>在react组件中生命周期函数有固定的执行顺序，<br>在一个组件中 总是先执行constructor构造函数 ，然后是 componentWillMount 组件挂载前，componentDidMount组件挂载完成，componentWillUnmount组件即将卸载，可以发现而我们通过setState方法触发组件重新渲染的时候只会触发组件的render方法，挂载阶段生命周期函数只会在第一次挂载组件时候执行，并不会重复执行，深入了解组件的生命周期对以后react的学习将会大有裨益。</li>
</ol>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-挂载阶段的组件生命周期（二）"><a href="#react-挂载阶段的组件生命周期（二）" class="headerlink" title="react 挂载阶段的组件生命周期（二）"></a>react 挂载阶段的组件生命周期（二）</h4><blockquote>
<p>1.一般来说我们初始化组件的工作都在constructor里面做，而一些启动工作例如：ajax获取，设置定时器等都会在组件即将挂载componentWillMount时做，而我们可以看到如果我们在一个组件中设置了定时器而没有清除，即使组件被销毁但是定时的内存却没有被释放，这时候就会造成非常严重的内存泄漏，所以一般来说对组件的一些垃圾清理工作我们都在组件销毁comWillUnmount时做，而组件加载完成componentDidMount我们一般放入一些依赖dom的工作利例如动画。</p>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-更新阶段的组件生命周期"><a href="#react-更新阶段的组件生命周期" class="headerlink" title="react 更新阶段的组件生命周期"></a>react 更新阶段的组件生命周期</h4><blockquote>
<ol>
<li>react 中当我们调用setState方法使得组件重新渲染并把组件的变化应用到DOM元素上的过程叫做组件的更新阶段，这是一个组件的变化过程，如果想要完全理解更新阶段的生命周期需要对virtu-DOM策略有比较深入的了解，有如下函数：<ul>
<li>shouldComponentUpdate(nextProps,nextState):你可以通过这个方法控制组件是否重新渲染，如果返回false那么组件就不会重新渲染，这个生命周期在react优化中非常有用</li>
<li>componentWillReceiveProps(nextProps)：组件从父组件接收到新的 props 之前调用。</li>
<li>componentWillUpdate()：组件开始重新渲染之前调用。</li>
<li>componentDidUpdate()：组件重新渲染并且把<font color="red">更改变更到真实的 DOM 以后</font>调用。</li>
</ul>
</li>
</ol>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-ref和DOM操作"><a href="#react-ref和DOM操作" class="headerlink" title="react ref和DOM操作"></a>react ref和DOM操作</h4><blockquote>
<ol>
<li>虽然在react 我们大多数情况下不需要直接跟DOM打交道，但是有些时候我们却不得不这么做例如让一个input自动聚焦，所以react 提供了ref属性来帮助我们获取已经挂载的真是的DOM节点，你可以给任意元素添加这个属性，甚至包括组件但是获取到的是react内部初始化的类组建的实例，另外需要注意的是我们对于ref 能不用就不用，特别要避免react本来就可以帮助你做的更新页面和事件监听，多余的DOM操作实际上就违背了使用react的初衷。</li>
</ol>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-props-children和容器类组件"><a href="#react-props-children和容器类组件" class="headerlink" title="react props.children和容器类组件"></a>react props.children和容器类组件</h4><blockquote>
<ol>
<li>在react中有一类组件充当了容器的作用，他定义了一种外层结构形式，你可以往其中塞入任意的内容，react默认支持像普通HTML那样内嵌的写法，所有嵌套在组件中的JSX都可以在组件中通过props.children 获取到，其实props.children就是一个数组，react其实把我们嵌套的JSX元素都放到了数组中，然后通过props.children传给了card，由于JSX会把表达式中的数组每一项罗列下来显示，所以嵌套的JSX结构都会显示在容器组件中，这种嵌套内容成了props.children数组的机制使得我们编写组件变得非常的灵活，我们甚至可以在组件内部把数组中的JSX安置在不同的地方，这种组件编写方式在编写容器类型的组件当中非常有用。而在实际的 React.js 项目当中，我们几乎每天都需要用这种方式来编写组件。</li>
</ol>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-dangerouslySetHTML和style属性"><a href="#react-dangerouslySetHTML和style属性" class="headerlink" title="react dangerouslySetHTML和style属性"></a>react dangerouslySetHTML和style属性</h4><blockquote>
<ol>
<li>dangerouslyHTML是一个比较危险的属性，只有当我们需要动态改变HTML结构的时候才用得到，所以react官方把设置这个属性的操作复杂化防止过多的使用它</li>
<li>style react中的style属性接受一个style对象做参数，并且属性的键使用驼峰命名法。</li>
</ol>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-PropTypes和组件参数验证"><a href="#react-PropTypes和组件参数验证" class="headerlink" title="react PropTypes和组件参数验证"></a>react PropTypes和组件参数验证</h4><blockquote>
<ol>
<li><p>通过 PropTypes 给组件的参数做类型限制，可以在帮助我们迅速定位错误，这在构建大型应用程序的时候特别有用；另外，给组件加上 propTypes，也让组件的开发、使用更加规范清晰。<br>这里建议大家写组件的时候尽量都写 propTypes，有时候有点麻烦，但是是值得的。</p>
</li>
<li><p>另外所有类型是 PropTypes.any</p>
</li>
</ol>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-组件内容的编写顺序"><a href="#react-组件内容的编写顺序" class="headerlink" title="react 组件内容的编写顺序"></a>react 组件内容的编写顺序</h4><blockquote>
<ol>
<li>static 开头的类属性，如 defaultProps、propTypes。</li>
<li>构造函数，constructor。</li>
<li>getter/setter（还不了解的同学可以暂时忽略）。</li>
<li>组件生命周期。</li>
<li>_开头的私有方法。</li>
<li>事件监听方法，handle*。</li>
<li>render<em>开头的方法，有时候 render() 方法里面的内容会分开到&gt; 8. 不同函数里面进行，这些函数都以 render</em> 开头。</li>
<li>render() 方法。<br>当我们坚持使用这种顺序来写那么维护起来就会很方便。</li>
</ol>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-高阶组件"><a href="#react-高阶组件" class="headerlink" title="react 高阶组件"></a>react 高阶组件</h4><blockquote>
<ol>
<li>高阶组件就是一个函数，传给它一个组件，它返回一个新的组件。新的组件使用传入的组件作为子组件。高阶组件的作用是用于代码复用，可以把组件之间可复用的代码、逻辑抽离到高阶组件当中。新的组件和传入的组件通过 props 传递信息。高阶组件有助于提高我们代码的灵活性，逻辑的复用性。灵活和熟练地掌握高阶组件的用法需要经验的积累还有长时间的思考和练习，如果你觉得本章节的内容无法完全消化和掌握也没有关系，可以先简单了解高阶组件的定义、形式和作用即可。</li>
</ol>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-context"><a href="#react-context" class="headerlink" title="react context"></a>react context</h4><blockquote>
<p>1.一个组件可以通过 getChildContext 方法返回一个对象，这个对象就是子树的 context，提供 context 的组件必须提供 childContextTypes 作为 context 的声明和验证。如果一个组件设置了 context，那么它的子组件都可以直接访问到里面的内容，它就像这个组件为根的子树的全局变量。任意深度的子组件都可以通过 contextTypes 来声明你想要的 context 里面的哪些状态，然后可以通过 this.context 访问到那些状态。context 打破了组件和组件之间通过 props 传递数据的规范，极大地增强了组件之间的耦合性。而且，就如全局变量一样，context 里面的数据能被随意接触就能被随意修改，每个组件都能够改 context 里面的内容会导致程序的运行不可预料。但是这种机制对于前端应用状态管理来说是很有帮助的，因为毕竟很多状态都会在组件之间进行共享，context 会给我们带来很大的方便。一些第三方的前端应用状态管理的库（例如 Redux）就是充分地利用了这种机制给我们提供便利的状态管理服务。但我们一般不需要手动写 context，也不要用它，只需要用好这些第三方的应用状态管理库就行了。</p>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-Redux"><a href="#react-Redux" class="headerlink" title="react Redux"></a>react Redux</h4><blockquote>
<ol>
<li><p>Redux 是一种新型的前端架构模式，它是Flux架构的一个变种，<br>我们需要注意的是Redux和react-redux 并不是一个东西，react-redux其实是Redux模式在react的具体体现</p>
</li>
<li><p>为什么需要Redux，我们可以发现，大多数情况下我们的组件之间都需要共享数据，之前我们的做法是提升状态，但是往往当项目层级较多的时候，这样是极其混乱的，另外公共的共享状态，因为每个子组件都可以修改，所以这会导致不可预料的结果出现，所以我们需要一个固定的准则来实现共享数据并且实现对数据的可控性，这样Redux就是解决了这样的问题。</p>
</li>
</ol>
</blockquote>
<p><img src="http://huzidaha.github.io/static/assets/img/posts/CA34AC20-F3C0-438F-AD64-66C5E0986669.png" alt=""></p>
<p><img src="http://huzidaha.github.io/static/assets/img/posts/7536BBF9-6563-4FD5-8359-28D3A5254EE7.png" alt=""></p>
<blockquote>
<ol>
<li>在这个小节，现在我们有了一个比较通用的 createStore，它可以产生一种我们新定义的数据类型 store，通过 store.getState 我们获取共享状态，而且我们约定只能通过 store.dispatch 修改共享状态。store 也允许我们通过 store.subscribe 监听数据数据状态被修改了，并且进行后续的例如重新渲染页面的操作。</li>
<li>纯函数（Pure Function）<ul>
<li>一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数</li>
<li>返回结果只依赖于它的参数，绝对不依赖于外部任何数据，这样的话函数运行的结果永远都是可预测的</li>
<li>执行过程中没有副作用，就是函数执行过程中不对外部产生可观察的变化，例如 AJAX操作，调用DOM API 修改页面，window.reload刷新页面，甚至控制台打印数据都是可观察的变化</li>
</ul>
</li>
<li>共享结构对象，通过es6的&#123;…obj&#125;语法我们可以对对象进行浅拷贝，我们大概可以保证以后复制的对象大概有50%以上的内容具有共享结构<br>我们可以利用它来判断，让组件少做无用的渲染。<br><img src="http://huzidaha.github.io/static/assets/img/posts/C8A1EB09-2D4E-442E-AD6D-E4997B4AF1C1.png" alt=""></li>
</ol>
</blockquote>
<p><img src="http://huzidaha.github.io/static/assets/img/posts/4E4E9324-4659-4791-8957-137566C3A929.pngs" alt=""></p>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-动手实现React-redux（一）"><a href="#react-动手实现React-redux（一）" class="headerlink" title="react 动手实现React-redux（一）"></a>react 动手实现React-redux（一）</h4><blockquote>
<ol>
<li>我们在前面提过前端状态提升中，前端的应用状态当被多个组件影响或依赖时应把它提到所有的组件的父组件上，但是这样当结构复杂需要不断的提升，后来我们学习了context只要父组件设置了context对象那么它的子组件不管层级多深，都可以直接访问到，但是这样又导致了组件的不可预料性，那么我们为什么不把store和context结合起来了，这样每个子组件都可以去context获取store但是修改store又不是那么容易的事，这样就比较好的解决了我们的矛盾点。</li>
</ol>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-动手实现React-redux（五）"><a href="#react-动手实现React-redux（五）" class="headerlink" title="react 动手实现React-redux（五）"></a>react 动手实现React-redux（五）</h4><blockquote>
<ol>
<li>前面可以看到，我们虽然在大多数组件中去掉了关于context的逻辑但是，在index中还是无法去掉，因为它要负责存储store，所以我们可以写一个容器类组件，让它可以包裹传入的组件，它只有一个作用就是提供store；<br>这样我们的主体逻辑中就都避免了contex 的操作</li>
</ol>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-React-redux总结"><a href="#react-React-redux总结" class="headerlink" title="react React-redux总结"></a>react React-redux总结</h4><blockquote>
<ol>
<li>由于react没有提供很完善的解决方案来解决组件之间的共享状态的问题，而使用context来解决却会让程序变得不可预测，通过前几节，我们可以知道我们构建的createStore方法产生的store的内容是不可以随意修改的，而必须通过dispatch来告诉reducer你想做什么，验证通过后才能修改，所以我们尝试把context和store结合起来来解决这种矛盾。</li>
<li>第一个版本的store和context有很多缺陷，比如有大量重复的逻辑和对context依赖性国强，所以我们尝试通过构建一个高阶组件connect的方式把复杂的逻辑和对context的依赖放到connect函数里面，而其他组件保持Pure状态，然后通过props把参数传给普通组件，由于每个组件需要的数据和触发的action不一样，所以我们调整connect，让它可以接受两个参数mapStateToProps 和 mapDispatchToProps，让它知道这个组件需要什么数据和需要触发什么action；<br>3.最后为了把关于context的逻辑代码完全从我们的业务逻辑里面清除掉，我们又构建了一个Provider容器类组件，让它作为整个组件树的根节点，我们通过props传入store，把这个store放到容器组件的contex上，所以它所包裹的子组件都可以直接访问到，这样我们就简单实现了React-redux 的connect函数和Provider组件。</li>
</ol>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-Smart组件和Dumb组件"><a href="#react-Smart组件和Dumb组件" class="headerlink" title="react Smart组件和Dumb组件"></a>react Smart组件和Dumb组件</h4><blockquote>
<ol>
<li>Dumb组件，只会接受props并且渲染确定结果的组件我们把它叫做Dumb组件，这种组件只关心一件事，根据Props渲染，Dumb组件最好不要依赖除了react.js和Dumb以外的任何内容，这些组件的可复用性是最好的，他人可以放心使用；</li>
<li>Smart组件，这类组件它们专门做数据相关的应用逻辑，和各种数据打交道，和ajax打交道，然后把数据通过props传递给Dumb，它们带领Dumb组件完成复杂的应用程序逻辑。</li>
</ol>
</blockquote>
<p>——————————————————————————————-我是分割线</p>
<h4 id="react-redux和react-redux-实现评论"><a href="#react-redux和react-redux-实现评论" class="headerlink" title="react redux和react-redux 实现评论"></a>react redux和react-redux 实现评论</h4><blockquote>
<ol>
<li>胡子大哈推荐书写reducer习惯：<ul>
<li>定义action types</li>
<li>编写reducer</li>
<li>跟这个reducer相关的action creators</li>
</ul>
</li>
</ol>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/js学学习笔记-09/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daima Hao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="好带马的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/js学学习笔记-09/" itemprop="url">js学学习笔记-09</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T17:05:45+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#####2017/09/12</p>
<p>#####移动端开发</p>
<blockquote>
<p>把我们做好的产品放在手机上（PAD）观看=&gt;<code>响应式布局开发</code></p>
<p>基于现有的PC端产品做样式和布局的调整，让其在手机端也可以很好的观看。（一般情况下PC和移动端共用一套项目）</p>
<p> PC端和移动端是两套项目，PC就是PC的，不需要做响应式，而移动端需要做响应式也是一套单独的项目</p>
<ul>
<li>基于手机的浏览器输入网址或者扫描二维码访问我们开发的页面</li>
<li>在微信/QQ/微博等第三方平台中运行。</li>
<li>嵌入到自己公司的APP中（hybrid混合开发模式）</li>
</ul>
</blockquote>
<p>#####HTML5</p>
<blockquote>
<p>HTML的第五套版本，在传统的基础上增加或者更新的一些新的特性；</p>
<ul>
<li><p>对语义化标签的处理。</p>
<ul>
<li>新增语义化标签：header、footer、nav、section、main、article、aside、aside、figure、figcaption、hgroup、progress、tune、mark（高亮选中）、datalist、summary……</li>
<li>对传统的标签的语义修改： small（附属细则），strong（特殊强调，重点朗读），hr（分割分割线）……</li>
<li>删除一些标签：font，big……<br>以上标签不兼容，不兼容的情况下我们引入html5.min.js来兼容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if lt IE9]&gt;</span><br><span class="line">&lt;script src=`xxx.js`&gt;&lt;/script&gt;</span><br><span class="line">&lt;![end if]--&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>给传统的表单元素新增加了很多的类型</p>
<ul>
<li>传统类型：text、password………</li>
<li>新增的类型（不兼容IE低版本）：search、email…………..</li>
</ul>
</li>
</ul>
</blockquote>
<p>新增类型的优势：<br>1.在手机端可以调取出最符合用户输入的键盘（例如：类型是number调取出来的就是数字键盘）；<br>2.内置的验证机制（对于邮箱电话类型等，浏览器有内置的正则验证）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input：valid｛-合法的｝；</span><br><span class="line">input：inva｛-非法的｝；</span><br></pre></td></tr></table></figure></p>
<p>3.提供了强大的功能组件，例如：日历，滑动杆，调色板等；<br>4.placeholder 默认显示的文字；</p>
<p>移动端的表单，没有keydown/keyup等事件（因为移动端的键盘是虚拟键盘），我们统一使用input事件来代替上述事件操作；</p>
<blockquote>
<ul>
<li>新增音视频处理：<ul>
<li>音频：audio</li>
<li>视频：video</li>
<li>在IE低版本中依然采用传统的flash播放</li>
<li>真实项目中的音视频播放，我们都是采用别人写好的播放器插件来处理的（兼容video/兼容flash）</li>
</ul>
</li>
<li>canvas/svg</li>
<li>一些新兴的API（JS）<ul>
<li>本地存储：webStorage（localStorage、sessionStroage）；</li>
<li>检测地理位置信息的</li>
<li>web scoket</li>
<li>web works</li>
<li>离线存储</li>
<li>……</li>
</ul>
</li>
</ul>
</blockquote>
<p>#####CSS3</p>
<ul>
<li>新增选择器<ul>
<li>结构伪类选择器：<code>nth-child、nth-last-child、nth-of-type、nth-last-of-type、：not.....</code></li>
<li>目标伪类选择器：<code>:target、</code></li>
<li>属性选择器：<code>[attr=xxx]、[attr!=xxx]、[attr^=xxx]、[attr$=xxx]、[attr*=xxx]、[attr~=xxx]</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>transform </p>
<ul>
<li>transform-style：presreve-3d</li>
<li>transform-origin</li>
<li>translate（X|Y|Z）</li>
<li>rotate（X|Y|Z）</li>
<li>scale</li>
<li>skew</li>
<li>matrix</li>
</ul>
</li>
<li><p>transition</p>
<ul>
<li>transition-property：</li>
<li>…..</li>
</ul>
</li>
</ul>
<p>#####viewport</p>
<blockquote>
<p>常用手机尺寸<br>苹果：320（&lt;=iphone5s&gt;）、375(iphone6)、414(iphone6 plus)….<br>安卓：360、480、540、640…….</p>
<p>默认情况下手机上的HTML页面宽度默认都是980/1024的宽度，和手机有多宽没有关系</p>
<p> 如果想在320的手机上展示980需要把页面整体缩小大概三倍左右（需要自己缩放）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; </span><br><span class="line">content=&quot;width=device-width, </span><br><span class="line">user-scalable=no, </span><br><span class="line">initial-scale=1.0, </span><br><span class="line">maximum-scale=1.0, </span><br><span class="line">minimum-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>真实项目中我们不想让页面缩小，也不想让用户手指缩放，此时我们需要让HTML页面的宽度和手机宽度保持一致；设置页面的<code>viewport（layout viewport布局视口）</code></p>
<p><code>width=device-width:当前html页面等译手机设备的宽度</code><br><code>user-scaleable=no 禁止用户手动缩放</code>；<br><code>initial-scale=1.0/maximum-scale=1.0、minimum-scale=1.0：初始、最大、最小缩放比例都是1:1”也就是当前页面既不会放大也不会缩小（兼容部分安卓机器）</code></p>
<p>#####QQ音乐播放器</p>
<p><strong>设计稿</strong></p>
<blockquote>
<p>移动端开发的时候，设计师给我们的设计稿一般都是640<em>960（iPhone4）/640</em>1136（iPhone5）/750*1334（iPhone6） 在原有手机的基础上放大了二倍，这里涉及到了移动端开发的<code>DPR</code>（屏幕像素密度比）适配问题，<br>现在市面上的手机一般都是2倍或者3倍屏幕像素密度比（视网膜技术）</p>
</blockquote>
<p><strong>REM</strong></p>
<blockquote>
<p>一个css单位<br>px是固定单位：我们设置300px*200px的尺寸，不管设备怎么变，都会按照原有尺寸大小渲染，不受其它的影响<br>rem是相对单位：相对于当前页面根元素（html）的字体大小来设置的</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&amp;<span class="selector-id">#123</span>;</span><br><span class="line">	<span class="selector-tag">font-size</span><span class="selector-pseudo">:16px</span>;<span class="comment">/*此后在页面中1rem=16px*/</span></span><br><span class="line">&amp;<span class="selector-id">#125</span>;</span><br><span class="line"><span class="selector-class">.box</span>&amp;<span class="selector-id">#123</span>;</span><br><span class="line">	<span class="selector-tag">width</span><span class="selector-pseudo">:10rem</span>;<span class="comment">/*160px*/</span></span><br><span class="line">&amp;<span class="selector-id">#125</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果我们后期把html的字体大小改了，那么页面中所有以REM为单位的元素样式都跟着自动缩放了。</p>
<blockquote>
<p>REM响应式布局</p>
<ul>
<li>首先我们严格按照设计稿的尺寸写样式，只不过在写样式的时候，把所有的PX变为REM（假设设计稿是640的尺寸）</li>
<li>当我们把页面放在320的手机上，之前写的样式需要整体缩小一倍，此时没有必要一个个的样式更改，我们只需要把html的字体大小在原来的基础上缩小一倍即可（HTML的字体缩小，之前以REM为单位的值都会跟着缩小）</li>
<li>为了方便计算，我们一般把HTML的初始字体大小设置为100px（浏览器最小字体是10或者12px，我们缩放太小后浏览器识别不了。）；</li>
</ul>
</blockquote>
<p><em>**ZPETO</em></p>
<blockquote>
<p>zepto被称作小型的JQuery，PC端使用JQ，移动端使用ZP，JQ怎么用，ZP就怎么用；</p>
<p><strong> 区别</strong>：</p>
<ul>
<li>zp比jq更小：zp没有处理IE低版本兼容，而且只实现了JQ中最常用的功能。（animate实现了，show/hide快捷动画都没有…..）；</li>
<li>zp单独为移动端常用的操作封装了一些事件方法：tap点击、singleTap单击、doubleTap双击、longTap长按、swipe滑动、swipeLeft/right/up/down四个方向的滑动…..；</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/js学学习笔记-08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daima Hao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="好带马的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/js学学习笔记-08/" itemprop="url">js学学习笔记-08</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T17:05:42+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>####2017/08/20</p>
<h5 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h5><blockquote>
<p>jQuery的简介和版本</p>
<p>JQ是一款伟大的JavaScript类库，它里面提供了‘选择器’、‘DOM筛选’、‘事件处理’、‘动画处理’、‘AJAX/JSONP’、‘常用方法’等方面的内容（所谓类库就是方法的综合体，里面就提供了日常开发常用的功能，这些方法做了浏览器的兼容处理）</p>
<p>JQ一共有三大版本</p>
<p> 1.xxx：第一代版本（兼容所有浏览器）</p>
<ul>
<li>jquery.min.js</li>
<li>jquery-1.9.3.min.js</li>
<li>jquery-1.11.3.min.js<blockquote>
<p> 2.xxx：第二代版本（jquery）(鸡肋：对于IE6-8的兼容不好)<br>3.xxx：第三代版本（jquery）</p>
</blockquote>
</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/js学学习笔记-07/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daima Hao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="好带马的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/js学学习笔记-07/" itemprop="url">js学学习笔记-07</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T17:05:38+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>####<strong>2017/0817</strong></p>
<p>#####<strong>回调函数</strong></p>
<blockquote>
<p>把一个函数当作实参（值）传递给另外一个正在执行的函数，在另外一个函数执行的过程中，把我们传递的这个回调函数执行。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fuction fn(num,callBack)&amp;#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//-&gt;callBack:undefined</span></span><br><span class="line">		<span class="comment">//-&gt;在让回调函数执行之前，我们最好验证一下它是否是一个函数类型的值，如果是函数类型的使我们在执行，防止报错。</span></span><br><span class="line">		<span class="comment">//if （typeof callBack==='function'）&amp;#123;</span></span><br><span class="line">			callBack();</span><br><span class="line">		&amp;#125;</span><br><span class="line">		<span class="comment">//-&gt;callBack:function ()&amp;#123;...&amp;#125;</span></span><br><span class="line">		callBack &amp;&amp; callBack(); <span class="comment">//-&gt; 一般来说，真实项目中，大家对于callBack只会传递函数不会传任何东西。</span></span><br><span class="line">		<span class="comment">//传递的回调函数可以在FN中的任何一个位置执行：根据需求来规划即可。可以根据需求执行多次</span></span><br><span class="line">		<span class="comment">// 在回调函数的宿主函数（回调函数在哪执行，它的宿主函数就是谁，此时回调函数的宿主函数就是谁）中，</span></span><br><span class="line">			<span class="comment">//我们可以把回调函数执行，而且在宿主函数中可以接受回调函数的返回结果，以此来进行后续的一些操作。</span></span><br><span class="line">	&amp;#125;  </span><br><span class="line">fn(<span class="number">100</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)&amp;#123;&amp;#125;);</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>forEach<br>循环数组中的每一项（数组有几项，回调函数就被执行几次，每一次执行都会把当前数组遍历的这一项以及它的索引传递给回调函数）</p>
<p>map<br>遍历的语法和forEach相同，只不过它支持回调函数的返回值（forEach中的回调函数不支持返回值），回调函数中返回的是啥，相当于把数组的当前xiang</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/js学学习笔记-06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daima Hao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="好带马的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/js学学习笔记-06/" itemprop="url">js学学习笔记-06</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T17:05:35+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#####<strong>2017/08/08</strong></p>
<p>#####<strong><font color="red">继承（2）</font></strong></p>
<blockquote>
<p>OOP:(Object Oriented Programming)面对对象编程.<br>类的继承、封装、多态。</p>
</blockquote>
<p><strong>封装</strong></p>
<blockquote>
<p>把实现一个功能的JS 代码封装成一个函数，以后想实现这个功能，执行函数即可=&gt;’低耦合，高内聚’</p>
</blockquote>
<p><strong>多态</strong></p>
<blockquote>
<p>类具备多种形态：重载和重写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//-&gt;后台语言的重载：方法名相同，参数不同（参数的类型或者个数不一样）这样相当于两个不同的方法，通过传参的不一样，执行对应的方法。</span></span><br><span class="line">  public void sum（int num1,int num2）&amp;#123;</span><br><span class="line">			<span class="comment">//-&gt;code</span></span><br><span class="line">	&amp;#125;</span><br><span class="line">	public void sum（int num1）&amp;#123;</span><br><span class="line">			<span class="comment">//-&gt;code</span></span><br><span class="line">	&amp;#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">10</span>,<span class="number">20</span>);<span class="comment">//-&gt;执行第一个sum</span></span><br><span class="line">sum（<span class="number">10</span>）；<span class="comment">//-&gt;执行第二个sum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-&gt; JS中不存在类似于后台的重载，JS中如果方法名相同，其中一个会把其它相同的函数名都给覆盖掉，最后只保留一个，不管传递几个参数，都只执行一个。如果一定说有重载，那么JS中的重载就是，通过给一个方法传递不同的实参，在方法中我们判断传递的实参，来处理不同的事情（arguments）；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>（<span class="title">num1</span>,<span class="title">num2</span>）｛<span class="title">console</span>.<span class="title">log</span>(<span class="params"><span class="number">1</span></span>);｝</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">sum</span>（<span class="title">num1</span>）｛<span class="title">console</span>.(<span class="params"><span class="number">2</span></span>)｝;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">sum</span>(<span class="params"><span class="number">10</span>,<span class="number">20</span></span>)//=&gt;2</span></span><br><span class="line"><span class="function"><span class="title">sum</span>（10）//=&gt;2</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>继承</strong></p>
<blockquote>
<p>子类继承父类中属性和方法；在继承后，子类还可以把父类的属性和方法进行修改，这就是多态中的重写。</p>
<p>1.call继承(<em> </em> <em> </em> )<br> 只能让子类的实例继承私有的属性和方法。<br> 原理：在创建子类实例的时候，把父类当作普通函数执行，让函数中的this变为当前子类的实例（使用call改变this的指向），此时在父类函数体中写的this.xxx=xxx这些私有的属性和方法都被子类的实例占有了<br> 弊端：只能继承父类私有的属性</p>
<p>2.原型继承（<em> </em> <em> </em> *）<br>父类私有的属性和公有的属性方法都被子类继承了，而且都变成子类实例公有的属性和方法</p>
<p>原理：让子类的原型等于父亲类的一个实例（父类的实例能够拥有父类私有和公有的属性方法），这样子类的实例也同时拥有父类私有的和公有的;但是原型继承和遗传不太一样，遗传是把父母的基因克隆一份到自己的身上（call继承就是遗传），而原型继承仅仅是是让子类和父类之间建立了原型链的连接通道，子类实例所使用的父类的公有方法，依然在父类的原型上，<br>弊端：不管父类私有的还是公有的都变成子类公有的。</p>
<p> 3.冒充对象继承（*）<br> for in 既可以遍历私有的属性和方法也可以遍历部分它原型链上的属性和方法（所有可枚举的都可以遍历，不可枚举的不可遍历）==&gt;一般内置的属性和方法是不能枚举出来的。<br> 把父类的实例当作一个普通的对象，遍历循环，把父类的私有或者公有的属性和方法，可以放在子类的任意位置，随你喜好即可=&gt;一般不用</p>
<p>  for循环不能遍历公有的属性和方法</p>
<p>4.组合继承（<em> </em> <em> </em> *）<br>父类私有的在子类和父类都各有一份，代码重复(caill+原型)</p>
<p>5.寄生组合式继承（<em> </em> <em> </em> <em> </em> ）<br>它是把传统组合式继承中，父类私有的在子类私有和公有上各有一份，这个瑕疵点完善了一下。<br>父类私有的=》子类私有的（遗传式）；<br>父类公有的=》子类私有的（遗传式：把私有的克隆一份过来）<br>父类公有的=》子类公有的（非遗传式：让原型链之间建立连接的通道）</p>
<p> Object.create([obj])</p>
<p>  创建一个新的空对象<br>  让新创建的这个对象的<strong>proto</strong>指向<code>[obj]</code>;</p>
<p>6.ES6中的继承<br>采用的原理是：寄生组合式继承。</p>
<p>7.中间类继承</p>
<blockquote>
<p> 不兼容IE，因为使用了’<strong>proto</strong>‘</p>
</blockquote>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)&amp;#123;</span></span><br><span class="line">		var ary=[].slice.call(arguments)</span><br><span class="line">	&amp;#125;</span><br><span class="line">	<span class="built_in">arguments</span>.__proto__=<span class="built_in">Array</span>.prototype;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)&amp;#123; <span class="title">this</span>.&amp;#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> function A() &amp;#123;</span></span><br><span class="line"><span class="comment">     this.a="a";</span></span><br><span class="line"><span class="comment"> &amp;#125;</span></span><br><span class="line"><span class="comment"> function B() &amp;#123;</span></span><br><span class="line"><span class="comment">     this.b="b";</span></span><br><span class="line"><span class="comment">     A.call(this);</span></span><br><span class="line"><span class="comment"> &amp;#125;</span></span><br><span class="line"><span class="comment"> var b= new B;</span></span><br><span class="line"><span class="comment"> console.log(b);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function">     <span class="title">this</span>.<span class="title">a</span>="<span class="title">a</span>";</span></span><br><span class="line"><span class="function"> &amp;#125;</span></span><br><span class="line"><span class="function"> <span class="title">A</span>.<span class="title">prototype</span>.<span class="title">getA</span>=<span class="title">function</span> (<span class="params"></span>) &amp;#123;&amp;#125;;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="title">function</span> <span class="title">B</span>(<span class="params"></span>) &amp;#123;</span></span><br><span class="line"><span class="function">     <span class="title">this</span>.<span class="title">b</span>="<span class="title">b</span>";</span></span><br><span class="line"><span class="function">     <span class="title">var</span> <span class="title">objA</span>=<span class="title">new</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="function">     <span class="title">for</span>(<span class="params">var key in objA</span>)&amp;#123;</span></span><br><span class="line">         //this[key]=objA[key]</span><br><span class="line">         if(objA.hasOwnProperty(key))&amp;#123;</span><br><span class="line">             <span class="keyword">this</span>[key]=objA[key]</span><br><span class="line">         &amp;#125;else &amp;#123;</span><br><span class="line">             <span class="comment">//this.__proto__[key]=objA[key];</span></span><br><span class="line">             B.prototype[key]=objA[key]</span><br><span class="line">         &amp;#125;</span><br><span class="line">     &amp;#125;</span><br><span class="line"> &amp;#125;</span><br><span class="line"> B.prototype.getB=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) &amp;#123;&amp;#125;;</span></span><br><span class="line"><span class="function"> <span class="title">var</span> <span class="title">b</span>= <span class="title">new</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="function"> <span class="title">console</span>.<span class="title">log</span>(<span class="params">b</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="title">var</span> <span class="title">str</span>="1234";</span></span><br><span class="line"> var ary=[1,2,3];</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(str, <span class="string">"length"</span>));</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(ary, <span class="string">"length"</span>));<span class="comment">//getOwnPropertyDescriptor（ary，"length"）方法查看对象上的属性是否可配置，可枚举，可写还有value值</span></span><br></pre></td></tr></table></figure>
<p>#####<strong>Object.assian(目标对象，源对象1，源对象2……..)</strong></p>
<blockquote>
<p>如果目标对象中的属性具有相同的关键字，则源中的属性将被覆盖。后来的资源属性将同样覆盖早期的资源。  </p>
<p>该Object.assign()方法仅将可枚举和自己的属性从源对象复制到目标对象。它使用[[Get]]源和[[Set]]目标，所以它将调用getter和setter。因此，它分配属性，而不仅仅是复制或定义新属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型中Object.getOwnPropertyDescriptor()，Object.defineProperty()应该使用。</p>
<p>两者String和Symbol属性都被复制。</p>
<p>在出现错误的情况下，例如，如果属性不可写，TypeError则会引发a，target如果在引发错误之前添加了任何属性，则可以更改该对象。</p>
<p>请注意，Object.assign()不会抛出null或undefined源值。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/js学学习笔记-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daima Hao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="好带马的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/js学学习笔记-05/" itemprop="url">js学学习笔记-05</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T17:05:26+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>####2017/08/01</p>
<p>#####四、逻辑与（&amp;&amp;）和逻辑或（||）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;<span class="number">2</span>==<span class="number">2</span>)</span><br><span class="line">	<span class="comment">// -&gt; 逻辑与：左边的条件为真，右边条件也为真，整体才为真，否则就是假  =》 ‘并且’</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>（<span class="number">1</span>==<span class="number">1</span> || <span class="number">2</span>==<span class="number">2</span>）｛</span><br><span class="line">	｝	</span><br><span class="line"><span class="comment">// --&gt; 逻辑或：左右两面只要有一面为真，整体就为真，反之则为假 ==》‘或者’</span></span><br></pre></td></tr></table></figure>
<p>2.赋值运算符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//逻辑或：A||B，首先验证A真假，如果A为真就返回的结果是A，如果A为假就返回B不管B是真是假。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数初始化，如果参数没有传递，就给参数一个默认值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typeof num1==='undefined'?num1=0:null;(传统判断做法：麻烦)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	num1=num1||<span class="number">0</span>;</span><br><span class="line">	num2=num2||<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  -》我们这样处理参数初始化即可，比较简便，但是这样不严谨：传递至了，但是传递的是false/0/空字符串，这样返回的也是右边的值；</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fn(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑与：A&amp;B/,A如果返回真，返回右边的B，如果A为假，返回左边的A（和逻辑或的操作是相反的）</span></span><br><span class="line"></span><br><span class="line">fn &amp;&amp; fn();<span class="comment">//如果当前函数存在则让函数执行，否则函数不执行（不严谨：如果fn是10）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> fn===<span class="string">'function'</span>?fn():<span class="literal">null</span>;<span class="comment">//和上面的意思相同，但是这种方式严谨一些</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//===============</span></span><br><span class="line"><span class="comment">//一个运算当中既有 || 也有 &amp;&amp;，&amp;&amp;优先级高于 ||</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2&amp;&amp;3-&gt;3</span></span><br><span class="line"><span class="comment">3&amp;&amp;0-&gt;0</span></span><br><span class="line"><span class="comment">0||0-&gt;0</span></span><br><span class="line"><span class="comment">0||false-&gt;false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> res=<span class="number">1</span>||<span class="number">2</span>&amp;&amp;<span class="number">3</span>&amp;&amp;<span class="number">0</span>||<span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一些判断<br>[]==false：<strong><em>true__</em></strong> </p>
</blockquote>
<p>   ![]==false：<strong>__</strong>true<strong>_</strong><br>      []==![]：<strong><strong>_</strong></strong>true<strong>__<br>        Number(“13px”)==NaN：</strong>fasle<strong><strong>_</strong></strong><br>         5+”3”-2：<strong>___</strong>51<strong><strong>___</strong></strong><br>If(“3px”*3)&#123;alert(“true”)&#125;else&#123;alert(“false”)&#125;：_’<em>false’<strong><strong>__</strong></strong><br>If(“3px”+3)&#123;alert(“true”)&#125;else&#123;alert(“false”)&#125;：__</em>’true’<strong><em>__</em></strong><br>If（document.body）&#123;alert(“ok”);&#125;else&#123;alert(“no”)&#125;：<strong>__</strong>’ok’<strong><strong>_</strong></strong><br>alert([])：<strong><em>’  ’<strong><em>__</em></strong></em></strong><br>null==undefined：<strong><strong>true<strong><em>__</em></strong></strong></strong></p>
<ol>
<li>严格模式   //-&gt; 开启JS代码的严格模式，这句话需要写在当前作用域的起始行。</li>
</ol>
<blockquote>
<p>严格模式和非严格模式的区别：</p>
<ul>
<li>非严格模式下，创建一个变量，如果不带Var，相当于给window加了一个属性不会报错；</li>
<li>严格模式下不允许出现不带var的变量</li>
<li>非严格模式下，自执行函数的this是window</li>
<li>严格模式下，自执行函数中的this是undefined；</li>
<li>非严格模式下，如果不知道执行的主体，this都是window，但在严格模式下，如果不知道执行的主体，那么this就是undefined；</li>
</ul>
<p>非严格模式下，使用call改变this的主体，如果：</p>
<ul>
<li>xxx();   //window</li>
<li>xxx.call();  //widonw</li>
<li>xxx.call(null); //window</li>
<li>xxx.call(undefined); //window<br>严格模式下：</li>
<li>xxx();   //undefined</li>
<li>xxx.call();  //undefined</li>
<li>xxx.call(null); //null   <font color="purple"> null和undefined都是所属类的唯一对象所以也是对象，所以此处写什么就是什么  </font> </li>
<li>xxx.call(undefined); //undefined <font color="purple"> null和undefined都是所属类的唯一对象所以也是对象，所以此处写什么就是什么  </font><br>严格模式下：agruments和实参没有映射关系，agruments修改实参不变，非严格模式下agruments和实参有映射关系，agruments修改实参修改</li>
<li>arguments.callee 中存储的是函数本身：fn<ul>
<li>arguments.callee.caller 存储的函数在哪个作用域下执行的；</li>
<li>如果在全局下执行的，返回的结果是null，如果在函数AA中中执行，返回的是AA;</li>
<li>在严格模式下不允许使用arguments.callee和arguments.callee.caller这两个属性；</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'use strict'；当前JS代码都开启了严格模式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>（）｛</span></span><br><span class="line"><span class="function">	'<span class="title">use</span> <span class="title">strict</span>';// 当前作用域实行严格模式</span></span><br><span class="line"><span class="function">	<span class="title">b</span>=12;</span></span><br><span class="line"><span class="function">	<span class="title">consoloe</span>.<span class="title">log</span>(<span class="params">b</span>);//报错 不允许出现不带<span class="title">var</span>的变量</span></span><br><span class="line"><span class="function">｝</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>面向对象、原型和原型链</strong></p>
<p>- </p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/js学学习笔记-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daima Hao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="好带马的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/js学学习笔记-04/" itemprop="url">js学学习笔记-04</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T17:05:23+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>####2017/07/30</p>
<p>#####<strong>三丶1.单例模式</strong></p>
<blockquote>
<p>我们把描述东西特点特征的属性和方法汇总到一起，实现了分组分类，避免了相互之间的冲突；我们汇总在一起的那个对象，称之为一个单独的个体或者一个单独的实例 ==》’单例模式’<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var person1=&amp;#123;</span><br><span class="line">	name: <span class="string">'xxx'</span>;</span><br><span class="line">&amp;#125;</span><br><span class="line"></span><br><span class="line">var person2=&amp;#123;</span><br><span class="line"></span><br><span class="line">&amp;#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-&gt; person1和person2都是一个单独的个体（单独的实例），相互的name和age属性并不冲突，这就是基于‘单例模式’的设计思想构造出来，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-&gt; person1和person2 不仅仅称之为对象名了，在单例模式下，他们称之为：‘命名空间’</span></span><br></pre></td></tr></table></figure></p>
<p>单例模式：把描述事务的属性和方法放在同一个命名空间下，实现分组分类的作用，避免了相互之前的冲突（全局变量的污染）。</p>
<p> 单例模式 是项目开发中最常用的设计模式之一，我们团队协作按模块化开发的时候，基本上都是基于单例的思想设计的，避免相互代码的冲突。</p>
</blockquote>
<p>项目中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 高级单例模式，基于JS高阶编程技巧‘惰性函数思想’封装的单例模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> nameSpace=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)&amp;#123;//--&gt; 自执行函数执行形成一个不销毁的私有作用域 （闭包）</span></span><br><span class="line"><span class="function">	<span class="title">return</span>&amp;#123;</span></span><br><span class="line"><span class="function">		<span class="title">init</span>:<span class="title">function</span>(<span class="params"></span>)&amp;#123; //-&gt;'命令思想'</span></span><br><span class="line"><span class="function">			//--&gt; <span class="title">JS</span> <span class="title">node</span></span></span><br><span class="line"><span class="function">		&amp;#125;</span></span><br><span class="line"><span class="function">	&amp;#125;</span></span><br><span class="line"><span class="function">&amp;#125;)(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">/*模拟百度开发*/</span></span><br><span class="line"><span class="function">//1.频道页卡。</span></span><br><span class="line"><span class="function">//2.换肤</span></span><br><span class="line"><span class="function">//3..</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//-=&gt; <span class="title">Public</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">untils</span>=(<span class="params">function｛</span></span></span><br><span class="line"><span class="function"><span class="params">		</span></span></span><br><span class="line"><span class="function"><span class="params">		return｛</span></span></span><br><span class="line"><span class="function"><span class="params">			cookie：function（）｛｝，</span></span></span><br><span class="line"><span class="function"><span class="params">			.....</span></span></span><br><span class="line"><span class="function"><span class="params">		｝</span></span></span><br><span class="line"><span class="function"><span class="params">	｝</span></span></span><br><span class="line"><span class="function"><span class="params">					</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//--&gt;<span class="title">A</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">channelRender</span>=（<span class="title">function</span>（）｛</span></span><br><span class="line"><span class="function">	<span class="title">return</span> ｛</span></span><br><span class="line"><span class="function">		<span class="title">init</span>：<span class="title">function</span>（）｛。。。｝；</span></span><br><span class="line"><span class="function">		<span class="title">drge</span>：<span class="title">function</span>（）｛。。。｝；</span></span><br><span class="line"><span class="function">	｝</span></span><br><span class="line"><span class="function">｝）（）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//--&gt;<span class="title">B</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">channelSkinRender</span>=（<span class="title">function</span>（）｛</span></span><br><span class="line"><span class="function">	<span class="title">return</span> ｛</span></span><br><span class="line"><span class="function">		<span class="title">init</span>：<span class="title">function</span>（）｛。。。｝；</span></span><br><span class="line"><span class="function">		<span class="title">drge</span>：<span class="title">function</span>（）&amp;#123;</span></span><br><span class="line"><span class="function">			<span class="title">channelRender</span>.<span class="title">drag</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function">		｝；</span></span><br><span class="line"><span class="function">	｝</span></span><br><span class="line"><span class="function">｝）（）</span></span><br></pre></td></tr></table></figure></p>
<p>#####<strong>2、工厂模式</strong></p>
<blockquote>
<p>体现出了函数的封装特点：把实现一个功能的代码进行封装，以后想实现这个功能，直接的执行函数即可，这样不仅仅实现了代码的低耦合，高内聚， 而且实现了批量生产的快速开发 ==》“工厂模式”。</p>
</blockquote>
<p>#####<strong>3.面向对象编程思想（OOP）</strong></p>
<blockquote>
<p>OOP：Object Oriented Programming</p>
<ul>
<li>对象：JS中一切都是需要学习和研究的对象（泛指，抽象的名词）；</li>
<li>类：对象的具体细分（例如：自然界中分为植物类、动物类…..,每一个大类还可以分为小类….）</li>
<li>实例：每一个类别中具体的个体数事物。</li>
</ul>
<p>JS本身就是基于面向对象的思想构造出来的语言,所以JS中肯定有很多‘’内置类‘’。</p>
<ul>
<li>每一个数据类型都有自己所属的内置类，数据类型中的值都是所属类的实例<ul>
<li>Number：每一个数字都是它的实例；</li>
<li>String：每一个字符串都是它的实例；</li>
<li>Boolean： 布尔值是它的实例；</li>
<li>Null：</li>
<li>Udefined</li>
<li>Object：<ul>
<li>Array</li>
<li>RegExp</li>
<li>Date</li>
<li>…..</li>
</ul>
</li>
<li>Function</li>
<li>…</li>
</ul>
</li>
</ul>
</blockquote>
<p>每一个数据类型所用的方法，都是当前所属的类提前设定好的，实例就可以调取这些方法，例如：Array数组类，数组为每一个实例都提前设定了一些方法。</p>
<p><img src="./1501388206760.png" alt="Alt text"></p>
<blockquote>
<p>以上这些方法都是数组给它的实例提供的，所以数组的实例，是可以调取这些方法使用的。</p>
<ul>
<li>元素或节点集合类<ul>
<li>HTMLCollection：元素集合类，通过DOM的方法获取到的元素集合都是它实例。例如：getElementsByTagName、getElementsClassName…<ul>
<li>NodeList：节点集合类，通过DOM方法获取到的节点集合都是它的一个实例。例如：</li>
<li>getElementsByName、childNodes…..</li>
</ul>
</li>
</ul>
</li>
<li>DOM元素标签对应的内置类：每一个元素标签都有一个自己对应的内置类。<pre><code>+ div：HTMLDivElement
+ a：HTMLAnchorElement
+ p:HTMLParagraphElement
</code></pre></li>
</ul>
</blockquote>
<ul>
<li>HTMLElement（html元素类）</li>
<li>Element（元素类）</li>
<li>Node（节点类）</li>
<li>EventTarget（事件类）</li>
<li>Object</li>
</ul>
<p>#####4.构造函数设计模式</p>
<blockquote>
<p>基于面向对象的编程思想，创建‘自定义类’，基于自定义的类，创建相关的实例……..</p>
</blockquote>
<p>#####5.基于构造函数设计模式引申的原型模式</p>
<blockquote>
<p>原型是构造函数的引申，构造函数中公共属性部分就是由原型来掌控的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>所有的函数数据类型</span><br><span class="line">	-&gt;普通函数</span><br><span class="line">	-&gt;类</span><br><span class="line"><span class="number">2.</span>天生具备一个属性：prototype ，这个属性的值是一个对象，当前类的公共属性和方法都在这个对中</span><br><span class="line">存储着。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> prototype 天生具备一个属性：<span class="keyword">constructor</span>（构造函数），这个属性存储的值就是当前类（函数）本身，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.每一个对象数据类型</span><br><span class="line">		-&gt;普通对象｛｝</span><br><span class="line">		-&gt;数组和正则等</span><br><span class="line">		-&gt;类的实例</span><br><span class="line">		-&gt;函数也是对象</span><br><span class="line"> 也会天生自带一个属性：_proto_,这个属性存储的值是它对应类的prototype属性的值；</span><br><span class="line">// -&gt;理解：</span><br><span class="line">	fn=｛</span><br><span class="line">		prototype：｛</span><br><span class="line">			<span class="keyword">constructor</span>: fn;</span><br><span class="line">		｝</span><br><span class="line">	｝</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/js学学习笔记-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="daima Hao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="好带马的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/js学学习笔记-03/" itemprop="url">js学学习笔记-03</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T17:05:20+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>####2017/07/29</p>
<p>####二、JS性能优化：堆栈内存的销毁问题。</p>
<blockquote>
<p>堆内存的释放：</p>
<p> 如果有变量（函数名）占用了堆内存的地址，那么当前堆内存则不能释放。<br> 如果当前的堆内存地址，没有被任何的东西所引用，当前的堆内存就没用了，浏览器会在空闲的时候清理掉这些没有的堆内存（谷歌浏览器）</p>
<p>IE下的堆内存释放采用的是计数器机制，被一个变量占用，计数器累加1，如果之前的某个占用被移除，计数器减一；但是很多时候IE的计数器计数的时候出现问题，导致“内存泄漏”</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj=&amp;#123;name:xxxx&amp;#125;;//-&gt;obj=xxxfff000,此时的obj把堆内存占用了</span><br><span class="line"></span><br><span class="line">obj=null;//-&gt;obj不占用堆内存了，浏览器会在空闲的时候会销毁这个无用的堆内存；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*null : 空对象指针，不指向任何的堆内存；</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>栈内存（作用域）的释放</strong></p>
<p>全局作用域：浏览器加载页面的时候形成全局作用域，在浏览器中把当前页面关闭的时候，全局作用域销毁。</p>
<p>   私有作用域：函数执行的时候会形成私有作用域，一般情况下函数执行完毕，形成的这个私有作用域立即释放销毁了。</p>
<p>  特殊情况下，当私有作用域中的某一个东西（一般指的都是私有作用域中开辟的那个堆内存）被作用域以外的变量占用了，当前的私有作用域（栈内存）就不能销毁了；这个私有作用域不销毁，代表这它里面存储的私有变量也不会销毁了。</p>
</blockquote>
<p>####i++ 和++i的区别：<br>都是在自身基础上累加1，不同地方在于和其他值运算的时候，累加1在前还是在后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var i=10;</span><br><span class="line">console.log(5+i++); //先计算5+i，计算完成后再把i累加1  =&gt; 15 i=11；</span><br><span class="line"></span><br><span class="line">console.log(5+（i++）); //--&gt;加括号也是先运算再累加</span><br><span class="line"></span><br><span class="line">var i=10;</span><br><span class="line">console.log(5+（++i）); //先让i累加1，再计算5+i，  =&gt;16 i=11；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思考题：</span><br><span class="line">var i=4;</span><br><span class="line">var res=5+(1+i=i)</span><br><span class="line">+(i=i+i)</span><br><span class="line">+(i=i+1)</span><br><span class="line">+(i+1+i+=i);</span><br><span class="line">console.log(res,i);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>闭包</strong><br> 你了解过闭包吗？（易车面试题）</p>
<p>  目前外界普遍认为‘形成一个不销毁的私有作用域’才叫闭包，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var fn=(function()&amp;#123;</span><br><span class="line">	var n=12;</span><br><span class="line">	return function()&amp;#123;</span><br><span class="line">	console.log(++n);</span><br><span class="line">	&amp;#125;</span><br><span class="line">&amp;#125;)());</span><br></pre></td></tr></table></figure>
<p><strong>闭包的作用</strong>：</p>
<ul>
<li>保护里面的私有变量不受外界干扰（里面的变量和全局变量没关系。防止全局变量污染。）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//-&gt;例如：我们封装类库或者组建插件的时为了防止和全局变量冲突，我们都使用闭包把代码包裹起来（jQuery 就是这样处理的）</span><br><span class="line">	；（function（）｛</span><br><span class="line">		var fn=null;</span><br><span class="line">		var jQuery=function()&amp;#123;</span><br><span class="line">		....</span><br><span class="line">		&amp;#125;// -&gt; jQuery=xxxfff000；</span><br><span class="line">	</span><br><span class="line">	window.jQuery=window.$=jQuery; // -&gt;给全局增加了一个jQuery的属性的$的属性，这样在外面就可以使用jQuery或者$了。</span><br><span class="line">	｝）（）；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var fn=undefined；//-&gt; 和闭包中的fn没关系，防止了冲突和污染</span><br><span class="line"></span><br><span class="line">$()//-&gt;$=xxxfff000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>JS中同步编程和异步编程</strong></p>
<ul>
<li>同步： 自上而下依次执行，上面的事情没有处理完，下面的事情一直在等待。</li>
<li>异步：当上面的事情在等待执行的时候，我们不等，继续执行下面的事情。JS中的事件绑定属于异步编程。<br>1.回调函数。2.事件监听 3.发布和订阅  4.promise对象</li>
</ul>
</blockquote>
<p>####<strong>this</strong></p>
<blockquote>
<p>this这个，是执行方法的主体。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//自执行函数执行函数中的this是window</span><br><span class="line">// 以下所有规律都是在非严格模式下生效；</span><br><span class="line"></span><br><span class="line">	~function（）&amp;#123;</span><br><span class="line">		console.log（this）;// -&gt; widow</span><br><span class="line">	&amp;#125;（）；</span><br><span class="line"></span><br><span class="line">// -&gt; 给元素的事件绑定方法，当事件触发方法执行的时候，方法中的this是当前操作的元素。</span><br><span class="line"></span><br><span class="line">	oDiv.onclick=function（）｛</span><br><span class="line">		console.log（this）;//-&gt; oDiv;		</span><br><span class="line">	｝</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function fn()&amp;#123;</span><br><span class="line">	console.log(this);</span><br><span class="line">&amp;#125;</span><br><span class="line">var obj=&amp;#123;</span><br><span class="line">	n:100,</span><br><span class="line">	aa:fn;</span><br><span class="line">&amp;#125;</span><br><span class="line"></span><br><span class="line">// -&gt; 方法执行，看方法名前面是否有“点”，有“点”，“点”前面是谁，this就是谁，没有“点”，this就是window</span><br><span class="line"></span><br><span class="line">fn();// -&gt;this:window</span><br><span class="line">obj.aa();// this：obj</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>‘xxx’ in window  in是用来判断当前属性是否隶属于这个对象的，属于返回true，不属于返回false。</strong></p>
<p>var fn=function&#123;&#125;  –&gt;函数表达式<br>document.body.onclick=function&#123;&#125;也是函数表达式 ，当点击时执行函数，也可以document.body.onclick() 也可以不用点击就执行。模拟点击。</p>
<p>####<font color="lightblue">综合题</font></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="daima Hao" />
            
              <p class="site-author-name" itemprop="name">daima Hao</p>
              <p class="site-description motion-element" itemprop="description">you can do everything with javascript!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">daima Hao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
